package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	"fmt"
	"go-ent-project/graph/model"
	"go-ent-project/internal/ent"
	"log"

	"entgo.io/contrib/entgql"
)

// GetPoliceStations is the resolver for the getPoliceStations field.
func (r *queryResolver) GetPoliceStations(ctx context.Context, where *ent.PoliceStationWhereInput, after *string, first *int32, before *string, last *int32, orderBy *ent.PoliceStationOrder) (*model.PoliceStationConnection, error) {
	var afterCursor, beforeCursor *entgql.Cursor[int]
	if after != nil {
		cursor, err := DecodeCursor(*after)
		if err != nil {
			return nil, fmt.Errorf("invalid 'after' cursor: %v", err)
		}
		afterCursor = &entgql.Cursor[int]{Value: cursor}
	}

	if before != nil {
		cursor, err := DecodeCursor(*before)
		if err != nil {
			return nil, fmt.Errorf("invalid 'before' cursor: %v", err)
		}
		beforeCursor = &entgql.Cursor[int]{Value: cursor}
	}
	log.Printf("r.Client: %v", r.Client)
	log.Printf("first: %v, last: %v", first, last)
	log.Printf("after: %v, before: %v", after, before)

	var firstInt, lastInt *int
	if first != nil {
		val := int(*first)
		firstInt = &val
	}
	if last != nil {
		val := int(*last)
		lastInt = &val
	}
	query := r.Client.PoliceStation.Query()

	// Apply `where` filters if provided
	if where != nil {
		var err error
		query, err = where.Filter(query)
		if err != nil {
			return nil, fmt.Errorf("failed to apply filters: %v", err)
		}
	}

	paginate, err := query.Paginate(ctx, afterCursor, firstInt, beforeCursor, lastInt, ent.WithPoliceStationOrder(orderBy))
	if err != nil {
		return nil, err
	}
	var data []*ent.PoliceStation
	for _, node := range paginate.Edges {
		println("node: ", node.Node.ID)
		data = append(data, node.Node)
	}

	startCursor := convertCursorToString(paginate.PageInfo.StartCursor)
	endCursor := convertCursorToString(paginate.PageInfo.EndCursor)

	println(startCursor, endCursor, "sssss")

	return &model.PoliceStationConnection{
		PageInfo: &model.PageInfo{ // PageInfo struct
			HasNextPage:     paginate.PageInfo.HasNextPage,
			HasPreviousPage: paginate.PageInfo.HasPreviousPage,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		Edges: data,
	}, nil
}
