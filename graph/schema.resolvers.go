package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	"fmt"
	"go-ent-project/internal/ent"
	"log"

	"entgo.io/contrib/entgql"
)

// GetPoliceStations is the resolver for the getPoliceStations field.
func (r *queryResolver) GetPoliceStations(ctx context.Context, where *ent.PoliceStationWhereInput, after *string, first *int32, before *string, last *int32, orderBy *ent.PoliceStationOrder) ([]*ent.PoliceStation, error) {
	var afterCursor, beforeCursor *entgql.Cursor[int]
	if after != nil {
		cursor, err := DecodeCursor(*after)
		if err != nil {
			return nil, fmt.Errorf("invalid 'after' cursor: %v", err)
		}
		afterCursor = &entgql.Cursor[int]{Value: cursor}
	}

	if before != nil {
		cursor, err := DecodeCursor(*before)
		if err != nil {
			return nil, fmt.Errorf("invalid 'before' cursor: %v", err)
		}
		beforeCursor = &entgql.Cursor[int]{Value: cursor}
	}
	log.Printf("r.Client: %v", r.Client)
	log.Printf("first: %v, last: %v", first, last)
	log.Printf("after: %v, before: %v", after, before)

	var firstInt, lastInt *int
	if first != nil {
		val := int(*first)
		firstInt = &val
	}
	if last != nil {
		val := int(*last)
		lastInt = &val
	}

	paginate, err := r.Client.PoliceStation.Query().Paginate(ctx, afterCursor, firstInt, beforeCursor, lastInt)
	if err != nil {
		return nil, err
	}
	var data []*ent.PoliceStation
	for _, node := range paginate.Edges {
		data = append(data, node.Node)
	}

	return data, nil
}
