package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	_ "database/sql"
	"fmt"
	"go-ent-project/graph/model"
	"go-ent-project/internal/ent"
	"go-ent-project/internal/ent/camera"
	"go-ent-project/internal/ent/event"
	"go-ent-project/internal/ent/policestation"
	"time"
)

// PoliceStationCameraCounts is the resolver for the policeStationCameraCounts field.
func (r *queryResolver) PoliceStationCameraCounts(ctx context.Context) ([]*model.PoliceStationCameraCount, error) {
	psList, err := r.Client.PoliceStation.Query().WithCamera().All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch police stations: %w", err)
	}

	var result []*model.PoliceStationCameraCount
	for _, ps := range psList {
		result = append(result, &model.PoliceStationCameraCount{
			PoliceStationName: ps.Name,
			CameraCount:       len(ps.Edges.Camera),
		})
	}
	return result, nil
}

// PoliceStationCameraStatusCounts is the resolver for the policeStationCameraStatusCounts field.
func (r *queryResolver) PoliceStationCameraStatusCounts(ctx context.Context) ([]*model.PoliceStationCameraStatusCount, error) {
	psList, err := r.Client.PoliceStation.Query().WithCamera().All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch police stations: %w", err)
	}

	var result []*model.PoliceStationCameraStatusCount
	for _, ps := range psList {
		working := 0
		nonWorking := 0
		for _, cam := range ps.Edges.Camera {
			if cam.IsWorking {
				working++
			} else {
				nonWorking++
			}
		}
		result = append(result, &model.PoliceStationCameraStatusCount{
			PoliceStationName:     ps.Name,
			WorkingCameraCount:    working,
			NonWorkingCameraCount: nonWorking,
		})
	}
	return result, nil
}

// VehicleTrackingStats is the resolver for the vehicleTrackingStats field.
func (r *queryResolver) VehicleTrackingStats(ctx context.Context) ([]*model.VehicleTrackingStat, error) {
	type DayStat struct {
		Date         time.Time
		VehicleCount int
	}

	startOfMonth := time.Date(time.Now().Year(), time.Now().Month(), 1, 0, 0, 0, 0, time.UTC)
	startOfNextMonth := startOfMonth.AddDate(0, 1, 0)

	sqlStr := `
		SELECT created_at::date AS date, COUNT(*) AS count
		FROM events
		WHERE created_at >= $1 AND created_at < $2
		GROUP BY date
		ORDER BY date;
	`

	rows, err := r.SQL.QueryContext(ctx, sqlStr, startOfMonth, startOfNextMonth)
	if err != nil {
		return nil, fmt.Errorf("failed to execute raw SQL for vehicle tracking stats: %w", err)
	}
	defer rows.Close()

	var results []*model.VehicleTrackingStat
	for rows.Next() {
		var stat DayStat
		if err := rows.Scan(&stat.Date, &stat.VehicleCount); err != nil {
			return nil, fmt.Errorf("row scan error: %w", err)
		}
		results = append(results, &model.VehicleTrackingStat{
			Date:         stat.Date.Format("2006-01-02"),
			VehicleCount: stat.VehicleCount,
		})
	}

	return results, nil
}

// DashboardStats is the resolver for the dashboardStats field.
func (r *queryResolver) DashboardStats(ctx context.Context) (*model.DashboardStats, error) {
	// Count users
	totalUsers, err := r.Client.User.Query().Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count users: %w", err)
	}

	// Count all cameras
	totalCameras, err := r.Client.Camera.Query().Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count cameras: %w", err)
	}

	// Count working cameras
	workingCameras, err := r.Client.Camera.Query().Where(
		camera.IsWorking(true),
	).Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count working cameras: %w", err)
	}

	return &model.DashboardStats{
		TotalUsers:     totalUsers,
		TotalCameras:   totalCameras,
		WorkingCameras: workingCameras,
	}, nil
}

// PoliceStationVehicleCounts is the resolver for the policeStationVehicleCounts field.
func (r *queryResolver) PoliceStationVehicleCounts(ctx context.Context) ([]*model.PoliceStationVehicleCount, error) {
	stations, err := r.Client.PoliceStation.Query().WithCar().All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch stations: %w", err)
	}
	var result []*model.PoliceStationVehicleCount
	for _, ps := range stations {
		result = append(result, &model.PoliceStationVehicleCount{
			PoliceStationName: ps.Name,
			VehicleCount:      len(ps.Edges.Car),
		})
	}
	return result, nil
}

// DistrictVehicleCounts returns total vehicles per district.
func (r *queryResolver) DistrictVehicleCounts(ctx context.Context) ([]*model.DistrictVehicleCount, error) {
	results := make([]*model.DistrictVehicleCount, 0)
	err := r.Client.PoliceStation.Query().GroupBy(policestation.FieldDistrict).Aggregate(ent.Count()).Scan(ctx, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch district vehicle stats: %w", err)
	}
	var result []*model.DistrictVehicleCount
	for _, d := range results {
		result = append(result, &model.DistrictVehicleCount{
			District:     d.District,
			VehicleCount: d.VehicleCount,
		})
	}
	return result, nil
}

// EventsPerHour returns number of events grouped by hour of the current day.
func (r *queryResolver) EventsPerHour(ctx context.Context) ([]*model.EventHourStat, error) {
	type HourStat struct {
		Hour       int
		EventCount int
	}

	start := time.Now().Truncate(24 * time.Hour)
	end := start.Add(24 * time.Hour)

	sqlStr := `
		SELECT EXTRACT(HOUR FROM created_at)::int AS hour, COUNT(*) AS count
		FROM events
		WHERE created_at >= $1 AND created_at < $2
		GROUP BY hour
		ORDER BY hour;
	`

	rows, err := r.SQL.QueryContext(ctx, sqlStr, start, end)
	if err != nil {
		return nil, fmt.Errorf("failed to execute raw SQL for hourly stats: %w", err)
	}
	defer rows.Close() // ğŸ”‘ Close the result set

	var results []*model.EventHourStat
	for rows.Next() {
		var stat HourStat
		if err := rows.Scan(&stat.Hour, &stat.EventCount); err != nil {
			return nil, fmt.Errorf("row scan error: %w", err)
		}
		results = append(results, &model.EventHourStat{
			Hour:       fmt.Sprintf("%02d:00", stat.Hour),
			EventCount: stat.EventCount,
		})
	}

	return results, nil
}

// EventsByCamera returns number of events per camera.
func (r *queryResolver) EventsByCamera(ctx context.Context) ([]*model.CameraEventStat, error) {
	type CameraStat struct {
		CameraID   string `json:"camera_id"`
		EventCount int    `json:"count"`
	}
	start := time.Now().Truncate(24 * time.Hour)
	end := start.Add(24 * time.Hour)
	var stats []CameraStat
	err := r.Client.Event.Query().
		Where(event.CreatedAtGTE(start), event.CreatedAtLT(end)).
		GroupBy(event.FieldSnapDeviceID).
		Aggregate(ent.Count()).
		Scan(ctx, &stats)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch event stats by camera: %w", err)
	}

	var result []*model.CameraEventStat
	for _, row := range stats {
		result = append(result, &model.CameraEventStat{
			CameraID:   r.Client.Camera.Query().Where(camera.ImeiEQ(row.CameraID)).OnlyX(ctx).Name,
			EventCount: row.EventCount,
		})
	}
	return result, nil
}
