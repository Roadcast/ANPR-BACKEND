package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	"fmt"
	"go-ent-project/graph/model"
	"go-ent-project/internal/ent"
	"go-ent-project/internal/ent/camera"
	"go-ent-project/internal/ent/event"
	"time"
)

// PoliceStationCameraCounts is the resolver for the policeStationCameraCounts field.
func (r *queryResolver) PoliceStationCameraCounts(ctx context.Context) ([]*model.PoliceStationCameraCount, error) {
	psList, err := r.Client.PoliceStation.Query().WithCamera().All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch police stations: %w", err)
	}

	var result []*model.PoliceStationCameraCount
	for _, ps := range psList {
		result = append(result, &model.PoliceStationCameraCount{
			PoliceStationName: ps.Name,
			CameraCount:       len(ps.Edges.Camera),
		})
	}
	return result, nil
}

// PoliceStationCameraStatusCounts is the resolver for the policeStationCameraStatusCounts field.
func (r *queryResolver) PoliceStationCameraStatusCounts(ctx context.Context) ([]*model.PoliceStationCameraStatusCount, error) {
	psList, err := r.Client.PoliceStation.Query().WithCamera().All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch police stations: %w", err)
	}

	var result []*model.PoliceStationCameraStatusCount
	for _, ps := range psList {
		working := 0
		nonWorking := 0
		for _, cam := range ps.Edges.Camera {
			if cam.IsWorking {
				working++
			} else {
				nonWorking++
			}
		}
		result = append(result, &model.PoliceStationCameraStatusCount{
			PoliceStationName:     ps.Name,
			WorkingCameraCount:    working,
			NonWorkingCameraCount: nonWorking,
		})
	}
	return result, nil
}

// VehicleTrackingStats is the resolver for the vehicleTrackingStats field.
func (r *queryResolver) VehicleTrackingStats(ctx context.Context) ([]*model.VehicleTrackingStat, error) {
	type result struct {
		CreatedAt    time.Time `json:"created_at"`
		VehicleCount int       `json:"count"`
	}

	var rows []result
	err := r.Client.Event.
		Query().
		GroupBy(event.FieldCreatedAt).
		Aggregate(ent.Count()).
		Scan(ctx, &rows)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch vehicle stats: %w", err)
	}

	var output []*model.VehicleTrackingStat
	for _, row := range rows {
		output = append(output, &model.VehicleTrackingStat{
			Date:         row.CreatedAt.Format("2006-01-02"),
			VehicleCount: row.VehicleCount,
		})
	}

	return output, nil
}

// DashboardStats is the resolver for the dashboardStats field.
func (r *queryResolver) DashboardStats(ctx context.Context) (*model.DashboardStats, error) {
	// Count users
	totalUsers, err := r.Client.User.Query().Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count users: %w", err)
	}

	// Count all cameras
	totalCameras, err := r.Client.Camera.Query().Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count cameras: %w", err)
	}

	// Count working cameras
	workingCameras, err := r.Client.Camera.Query().Where(
		camera.IsWorking(true),
	).Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count working cameras: %w", err)
	}

	return &model.DashboardStats{
		TotalUsers:     totalUsers,
		TotalCameras:   totalCameras,
		WorkingCameras: workingCameras,
	}, nil
}
