package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	"fmt"
	"go-ent-project/graph/model"
	"go-ent-project/internal/ent/user"
	"go-ent-project/utils/auth"
	"go-ent-project/utils/middleware"
	"time"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.LoginResponse, error) {
	// Fetch user by email
	authUser, err := r.Client.User.Query().Where(user.EmailEQ(email)).Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("invalid email or password")
	}

	// Validate password (assuming passwords are hashed)
	if !auth.ValidatePassword(password, authUser.Password) {
		return nil, fmt.Errorf("invalid email or password")
	}

	// Generate access and refresh tokens
	accessToken, refreshToken, err := auth.GenerateToken(authUser.ID, authUser.RoleID, authUser.Password, authUser.Active)
	if err != nil {
		return nil, fmt.Errorf("failed to generate tokens: %v", err)
	}

	return &model.LoginResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshToken,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Extract user from context
	_, err := middleware.GetUserFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to retrieve user from context: %v", err)
	}

	// Blacklist the token (assume the token is tied to the user's session)
	token, _ := middleware.ExtractTokenFromContext(ctx)
	if token == "" {
		return false, fmt.Errorf("failed to extract token")
	}

	// Use a dummy expiration for demonstration; replace with actual session expiration logic
	expiry := 24 * time.Hour
	err = auth.AddToBlacklist(token, expiry)
	if err != nil {
		return false, fmt.Errorf("failed to blacklist token: %v", err)
	}

	return true, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.RefreshTokenResponse, error) {
	claims, err := auth.ValidateTokenWithDB(ctx, refreshToken, r.Client)
	if err != nil {
		return nil, fmt.Errorf("invalid or expired refresh token")
	}

	// Fetch user details from DB
	authUser, err := r.Client.User.Get(ctx, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}

	// Regenerate tokens
	accessToken, newRefreshToken, err := auth.GenerateToken(authUser.ID, authUser.RoleID, authUser.Password, authUser.Active)
	if err != nil {
		return nil, fmt.Errorf("failed to generate tokens: %v", err)
	}

	return &model.RefreshTokenResponse{
		AccessToken:  accessToken,
		RefreshToken: newRefreshToken,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
