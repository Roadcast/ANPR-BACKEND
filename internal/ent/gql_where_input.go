// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"go-ent-project/internal/ent/camera"
	"go-ent-project/internal/ent/car"
	"go-ent-project/internal/ent/permission"
	"go-ent-project/internal/ent/policestation"
	"go-ent-project/internal/ent/predicate"
	"go-ent-project/internal/ent/role"
	"go-ent-project/internal/ent/user"
	"time"
)

// CameraWhereInput represents a where input for filtering Camera queries.
type CameraWhereInput struct {
	Predicates []predicate.Camera  `json:"-"`
	Not        *CameraWhereInput   `json:"not,omitempty"`
	Or         []*CameraWhereInput `json:"or,omitempty"`
	And        []*CameraWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "imei" field predicates.
	Imei             *string  `json:"imei,omitempty"`
	ImeiNEQ          *string  `json:"imeiNEQ,omitempty"`
	ImeiIn           []string `json:"imeiIn,omitempty"`
	ImeiNotIn        []string `json:"imeiNotIn,omitempty"`
	ImeiGT           *string  `json:"imeiGT,omitempty"`
	ImeiGTE          *string  `json:"imeiGTE,omitempty"`
	ImeiLT           *string  `json:"imeiLT,omitempty"`
	ImeiLTE          *string  `json:"imeiLTE,omitempty"`
	ImeiContains     *string  `json:"imeiContains,omitempty"`
	ImeiHasPrefix    *string  `json:"imeiHasPrefix,omitempty"`
	ImeiHasSuffix    *string  `json:"imeiHasSuffix,omitempty"`
	ImeiEqualFold    *string  `json:"imeiEqualFold,omitempty"`
	ImeiContainsFold *string  `json:"imeiContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CameraWhereInput) AddPredicates(predicates ...predicate.Camera) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CameraWhereInput filter on the CameraQuery builder.
func (i *CameraWhereInput) Filter(q *CameraQuery) (*CameraQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCameraWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCameraWhereInput is returned in case the CameraWhereInput is empty.
var ErrEmptyCameraWhereInput = errors.New("ent: empty predicate CameraWhereInput")

// P returns a predicate for filtering cameras.
// An error is returned if the input is empty or invalid.
func (i *CameraWhereInput) P() (predicate.Camera, error) {
	var predicates []predicate.Camera
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, camera.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Camera, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, camera.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Camera, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, camera.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, camera.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, camera.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, camera.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, camera.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, camera.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, camera.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, camera.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, camera.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, camera.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, camera.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, camera.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, camera.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, camera.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, camera.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, camera.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, camera.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, camera.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, camera.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, camera.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, camera.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, camera.NameContainsFold(*i.NameContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, camera.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, camera.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, camera.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, camera.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, camera.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, camera.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, camera.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, camera.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, camera.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, camera.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, camera.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, camera.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, camera.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Imei != nil {
		predicates = append(predicates, camera.ImeiEQ(*i.Imei))
	}
	if i.ImeiNEQ != nil {
		predicates = append(predicates, camera.ImeiNEQ(*i.ImeiNEQ))
	}
	if len(i.ImeiIn) > 0 {
		predicates = append(predicates, camera.ImeiIn(i.ImeiIn...))
	}
	if len(i.ImeiNotIn) > 0 {
		predicates = append(predicates, camera.ImeiNotIn(i.ImeiNotIn...))
	}
	if i.ImeiGT != nil {
		predicates = append(predicates, camera.ImeiGT(*i.ImeiGT))
	}
	if i.ImeiGTE != nil {
		predicates = append(predicates, camera.ImeiGTE(*i.ImeiGTE))
	}
	if i.ImeiLT != nil {
		predicates = append(predicates, camera.ImeiLT(*i.ImeiLT))
	}
	if i.ImeiLTE != nil {
		predicates = append(predicates, camera.ImeiLTE(*i.ImeiLTE))
	}
	if i.ImeiContains != nil {
		predicates = append(predicates, camera.ImeiContains(*i.ImeiContains))
	}
	if i.ImeiHasPrefix != nil {
		predicates = append(predicates, camera.ImeiHasPrefix(*i.ImeiHasPrefix))
	}
	if i.ImeiHasSuffix != nil {
		predicates = append(predicates, camera.ImeiHasSuffix(*i.ImeiHasSuffix))
	}
	if i.ImeiEqualFold != nil {
		predicates = append(predicates, camera.ImeiEqualFold(*i.ImeiEqualFold))
	}
	if i.ImeiContainsFold != nil {
		predicates = append(predicates, camera.ImeiContainsFold(*i.ImeiContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, camera.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, camera.ActiveNEQ(*i.ActiveNEQ))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCameraWhereInput
	case 1:
		return predicates[0], nil
	default:
		return camera.And(predicates...), nil
	}
}

// CarWhereInput represents a where input for filtering Car queries.
type CarWhereInput struct {
	Predicates []predicate.Car  `json:"-"`
	Not        *CarWhereInput   `json:"not,omitempty"`
	Or         []*CarWhereInput `json:"or,omitempty"`
	And        []*CarWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "make" field predicates.
	Make             *string  `json:"make,omitempty"`
	MakeNEQ          *string  `json:"makeNEQ,omitempty"`
	MakeIn           []string `json:"makeIn,omitempty"`
	MakeNotIn        []string `json:"makeNotIn,omitempty"`
	MakeGT           *string  `json:"makeGT,omitempty"`
	MakeGTE          *string  `json:"makeGTE,omitempty"`
	MakeLT           *string  `json:"makeLT,omitempty"`
	MakeLTE          *string  `json:"makeLTE,omitempty"`
	MakeContains     *string  `json:"makeContains,omitempty"`
	MakeHasPrefix    *string  `json:"makeHasPrefix,omitempty"`
	MakeHasSuffix    *string  `json:"makeHasSuffix,omitempty"`
	MakeEqualFold    *string  `json:"makeEqualFold,omitempty"`
	MakeContainsFold *string  `json:"makeContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "year" field predicates.
	Year      *int  `json:"year,omitempty"`
	YearNEQ   *int  `json:"yearNEQ,omitempty"`
	YearIn    []int `json:"yearIn,omitempty"`
	YearNotIn []int `json:"yearNotIn,omitempty"`
	YearGT    *int  `json:"yearGT,omitempty"`
	YearGTE   *int  `json:"yearGTE,omitempty"`
	YearLT    *int  `json:"yearLT,omitempty"`
	YearLTE   *int  `json:"yearLTE,omitempty"`

	// "registration" field predicates.
	Registration             *string  `json:"registration,omitempty"`
	RegistrationNEQ          *string  `json:"registrationNEQ,omitempty"`
	RegistrationIn           []string `json:"registrationIn,omitempty"`
	RegistrationNotIn        []string `json:"registrationNotIn,omitempty"`
	RegistrationGT           *string  `json:"registrationGT,omitempty"`
	RegistrationGTE          *string  `json:"registrationGTE,omitempty"`
	RegistrationLT           *string  `json:"registrationLT,omitempty"`
	RegistrationLTE          *string  `json:"registrationLTE,omitempty"`
	RegistrationContains     *string  `json:"registrationContains,omitempty"`
	RegistrationHasPrefix    *string  `json:"registrationHasPrefix,omitempty"`
	RegistrationHasSuffix    *string  `json:"registrationHasSuffix,omitempty"`
	RegistrationEqualFold    *string  `json:"registrationEqualFold,omitempty"`
	RegistrationContainsFold *string  `json:"registrationContainsFold,omitempty"`

	// "color" field predicates.
	Color             *string  `json:"color,omitempty"`
	ColorNEQ          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGT           *string  `json:"colorGT,omitempty"`
	ColorGTE          *string  `json:"colorGTE,omitempty"`
	ColorLT           *string  `json:"colorLT,omitempty"`
	ColorLTE          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarWhereInput) AddPredicates(predicates ...predicate.Car) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarWhereInput filter on the CarQuery builder.
func (i *CarWhereInput) Filter(q *CarQuery) (*CarQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarWhereInput is returned in case the CarWhereInput is empty.
var ErrEmptyCarWhereInput = errors.New("ent: empty predicate CarWhereInput")

// P returns a predicate for filtering cars.
// An error is returned if the input is empty or invalid.
func (i *CarWhereInput) P() (predicate.Car, error) {
	var predicates []predicate.Car
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, car.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Car, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, car.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Car, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, car.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, car.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, car.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, car.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, car.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, car.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, car.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, car.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, car.IDLTE(*i.IDLTE))
	}
	if i.Make != nil {
		predicates = append(predicates, car.MakeEQ(*i.Make))
	}
	if i.MakeNEQ != nil {
		predicates = append(predicates, car.MakeNEQ(*i.MakeNEQ))
	}
	if len(i.MakeIn) > 0 {
		predicates = append(predicates, car.MakeIn(i.MakeIn...))
	}
	if len(i.MakeNotIn) > 0 {
		predicates = append(predicates, car.MakeNotIn(i.MakeNotIn...))
	}
	if i.MakeGT != nil {
		predicates = append(predicates, car.MakeGT(*i.MakeGT))
	}
	if i.MakeGTE != nil {
		predicates = append(predicates, car.MakeGTE(*i.MakeGTE))
	}
	if i.MakeLT != nil {
		predicates = append(predicates, car.MakeLT(*i.MakeLT))
	}
	if i.MakeLTE != nil {
		predicates = append(predicates, car.MakeLTE(*i.MakeLTE))
	}
	if i.MakeContains != nil {
		predicates = append(predicates, car.MakeContains(*i.MakeContains))
	}
	if i.MakeHasPrefix != nil {
		predicates = append(predicates, car.MakeHasPrefix(*i.MakeHasPrefix))
	}
	if i.MakeHasSuffix != nil {
		predicates = append(predicates, car.MakeHasSuffix(*i.MakeHasSuffix))
	}
	if i.MakeEqualFold != nil {
		predicates = append(predicates, car.MakeEqualFold(*i.MakeEqualFold))
	}
	if i.MakeContainsFold != nil {
		predicates = append(predicates, car.MakeContainsFold(*i.MakeContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, car.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, car.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, car.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, car.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, car.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, car.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, car.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, car.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, car.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, car.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, car.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, car.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, car.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Year != nil {
		predicates = append(predicates, car.YearEQ(*i.Year))
	}
	if i.YearNEQ != nil {
		predicates = append(predicates, car.YearNEQ(*i.YearNEQ))
	}
	if len(i.YearIn) > 0 {
		predicates = append(predicates, car.YearIn(i.YearIn...))
	}
	if len(i.YearNotIn) > 0 {
		predicates = append(predicates, car.YearNotIn(i.YearNotIn...))
	}
	if i.YearGT != nil {
		predicates = append(predicates, car.YearGT(*i.YearGT))
	}
	if i.YearGTE != nil {
		predicates = append(predicates, car.YearGTE(*i.YearGTE))
	}
	if i.YearLT != nil {
		predicates = append(predicates, car.YearLT(*i.YearLT))
	}
	if i.YearLTE != nil {
		predicates = append(predicates, car.YearLTE(*i.YearLTE))
	}
	if i.Registration != nil {
		predicates = append(predicates, car.RegistrationEQ(*i.Registration))
	}
	if i.RegistrationNEQ != nil {
		predicates = append(predicates, car.RegistrationNEQ(*i.RegistrationNEQ))
	}
	if len(i.RegistrationIn) > 0 {
		predicates = append(predicates, car.RegistrationIn(i.RegistrationIn...))
	}
	if len(i.RegistrationNotIn) > 0 {
		predicates = append(predicates, car.RegistrationNotIn(i.RegistrationNotIn...))
	}
	if i.RegistrationGT != nil {
		predicates = append(predicates, car.RegistrationGT(*i.RegistrationGT))
	}
	if i.RegistrationGTE != nil {
		predicates = append(predicates, car.RegistrationGTE(*i.RegistrationGTE))
	}
	if i.RegistrationLT != nil {
		predicates = append(predicates, car.RegistrationLT(*i.RegistrationLT))
	}
	if i.RegistrationLTE != nil {
		predicates = append(predicates, car.RegistrationLTE(*i.RegistrationLTE))
	}
	if i.RegistrationContains != nil {
		predicates = append(predicates, car.RegistrationContains(*i.RegistrationContains))
	}
	if i.RegistrationHasPrefix != nil {
		predicates = append(predicates, car.RegistrationHasPrefix(*i.RegistrationHasPrefix))
	}
	if i.RegistrationHasSuffix != nil {
		predicates = append(predicates, car.RegistrationHasSuffix(*i.RegistrationHasSuffix))
	}
	if i.RegistrationEqualFold != nil {
		predicates = append(predicates, car.RegistrationEqualFold(*i.RegistrationEqualFold))
	}
	if i.RegistrationContainsFold != nil {
		predicates = append(predicates, car.RegistrationContainsFold(*i.RegistrationContainsFold))
	}
	if i.Color != nil {
		predicates = append(predicates, car.ColorEQ(*i.Color))
	}
	if i.ColorNEQ != nil {
		predicates = append(predicates, car.ColorNEQ(*i.ColorNEQ))
	}
	if len(i.ColorIn) > 0 {
		predicates = append(predicates, car.ColorIn(i.ColorIn...))
	}
	if len(i.ColorNotIn) > 0 {
		predicates = append(predicates, car.ColorNotIn(i.ColorNotIn...))
	}
	if i.ColorGT != nil {
		predicates = append(predicates, car.ColorGT(*i.ColorGT))
	}
	if i.ColorGTE != nil {
		predicates = append(predicates, car.ColorGTE(*i.ColorGTE))
	}
	if i.ColorLT != nil {
		predicates = append(predicates, car.ColorLT(*i.ColorLT))
	}
	if i.ColorLTE != nil {
		predicates = append(predicates, car.ColorLTE(*i.ColorLTE))
	}
	if i.ColorContains != nil {
		predicates = append(predicates, car.ColorContains(*i.ColorContains))
	}
	if i.ColorHasPrefix != nil {
		predicates = append(predicates, car.ColorHasPrefix(*i.ColorHasPrefix))
	}
	if i.ColorHasSuffix != nil {
		predicates = append(predicates, car.ColorHasSuffix(*i.ColorHasSuffix))
	}
	if i.ColorEqualFold != nil {
		predicates = append(predicates, car.ColorEqualFold(*i.ColorEqualFold))
	}
	if i.ColorContainsFold != nil {
		predicates = append(predicates, car.ColorContainsFold(*i.ColorContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarWhereInput
	case 1:
		return predicates[0], nil
	default:
		return car.And(predicates...), nil
	}
}

// PermissionWhereInput represents a where input for filtering Permission queries.
type PermissionWhereInput struct {
	Predicates []predicate.Permission  `json:"-"`
	Not        *PermissionWhereInput   `json:"not,omitempty"`
	Or         []*PermissionWhereInput `json:"or,omitempty"`
	And        []*PermissionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "can_read" field predicates.
	CanRead    *bool `json:"canRead,omitempty"`
	CanReadNEQ *bool `json:"canReadNEQ,omitempty"`

	// "can_create" field predicates.
	CanCreate    *bool `json:"canCreate,omitempty"`
	CanCreateNEQ *bool `json:"canCreateNEQ,omitempty"`

	// "can_update" field predicates.
	CanUpdate    *bool `json:"canUpdate,omitempty"`
	CanUpdateNEQ *bool `json:"canUpdateNEQ,omitempty"`

	// "can_delete" field predicates.
	CanDelete    *bool `json:"canDelete,omitempty"`
	CanDeleteNEQ *bool `json:"canDeleteNEQ,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PermissionWhereInput) AddPredicates(predicates ...predicate.Permission) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PermissionWhereInput filter on the PermissionQuery builder.
func (i *PermissionWhereInput) Filter(q *PermissionQuery) (*PermissionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPermissionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPermissionWhereInput is returned in case the PermissionWhereInput is empty.
var ErrEmptyPermissionWhereInput = errors.New("ent: empty predicate PermissionWhereInput")

// P returns a predicate for filtering permissions.
// An error is returned if the input is empty or invalid.
func (i *PermissionWhereInput) P() (predicate.Permission, error) {
	var predicates []predicate.Permission
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, permission.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Permission, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, permission.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Permission, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, permission.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, permission.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, permission.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, permission.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, permission.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, permission.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, permission.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, permission.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, permission.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, permission.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, permission.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, permission.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, permission.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, permission.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, permission.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, permission.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, permission.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, permission.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, permission.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, permission.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, permission.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, permission.NameContainsFold(*i.NameContainsFold))
	}
	if i.CanRead != nil {
		predicates = append(predicates, permission.CanReadEQ(*i.CanRead))
	}
	if i.CanReadNEQ != nil {
		predicates = append(predicates, permission.CanReadNEQ(*i.CanReadNEQ))
	}
	if i.CanCreate != nil {
		predicates = append(predicates, permission.CanCreateEQ(*i.CanCreate))
	}
	if i.CanCreateNEQ != nil {
		predicates = append(predicates, permission.CanCreateNEQ(*i.CanCreateNEQ))
	}
	if i.CanUpdate != nil {
		predicates = append(predicates, permission.CanUpdateEQ(*i.CanUpdate))
	}
	if i.CanUpdateNEQ != nil {
		predicates = append(predicates, permission.CanUpdateNEQ(*i.CanUpdateNEQ))
	}
	if i.CanDelete != nil {
		predicates = append(predicates, permission.CanDeleteEQ(*i.CanDelete))
	}
	if i.CanDeleteNEQ != nil {
		predicates = append(predicates, permission.CanDeleteNEQ(*i.CanDeleteNEQ))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPermissionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return permission.And(predicates...), nil
	}
}

// PoliceStationWhereInput represents a where input for filtering PoliceStation queries.
type PoliceStationWhereInput struct {
	Predicates []predicate.PoliceStation  `json:"-"`
	Not        *PoliceStationWhereInput   `json:"not,omitempty"`
	Or         []*PoliceStationWhereInput `json:"or,omitempty"`
	And        []*PoliceStationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "identifier" field predicates.
	Identifier             *string  `json:"identifier,omitempty"`
	IdentifierNEQ          *string  `json:"identifierNEQ,omitempty"`
	IdentifierIn           []string `json:"identifierIn,omitempty"`
	IdentifierNotIn        []string `json:"identifierNotIn,omitempty"`
	IdentifierGT           *string  `json:"identifierGT,omitempty"`
	IdentifierGTE          *string  `json:"identifierGTE,omitempty"`
	IdentifierLT           *string  `json:"identifierLT,omitempty"`
	IdentifierLTE          *string  `json:"identifierLTE,omitempty"`
	IdentifierContains     *string  `json:"identifierContains,omitempty"`
	IdentifierHasPrefix    *string  `json:"identifierHasPrefix,omitempty"`
	IdentifierHasSuffix    *string  `json:"identifierHasSuffix,omitempty"`
	IdentifierEqualFold    *string  `json:"identifierEqualFold,omitempty"`
	IdentifierContainsFold *string  `json:"identifierContainsFold,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "parent_station" edge predicates.
	HasParentStation     *bool                      `json:"hasParentStation,omitempty"`
	HasParentStationWith []*PoliceStationWhereInput `json:"hasParentStationWith,omitempty"`

	// "child_stations" edge predicates.
	HasChildStations     *bool                      `json:"hasChildStations,omitempty"`
	HasChildStationsWith []*PoliceStationWhereInput `json:"hasChildStationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PoliceStationWhereInput) AddPredicates(predicates ...predicate.PoliceStation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PoliceStationWhereInput filter on the PoliceStationQuery builder.
func (i *PoliceStationWhereInput) Filter(q *PoliceStationQuery) (*PoliceStationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPoliceStationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPoliceStationWhereInput is returned in case the PoliceStationWhereInput is empty.
var ErrEmptyPoliceStationWhereInput = errors.New("ent: empty predicate PoliceStationWhereInput")

// P returns a predicate for filtering policestations.
// An error is returned if the input is empty or invalid.
func (i *PoliceStationWhereInput) P() (predicate.PoliceStation, error) {
	var predicates []predicate.PoliceStation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, policestation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PoliceStation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, policestation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PoliceStation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, policestation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, policestation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, policestation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, policestation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, policestation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, policestation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, policestation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, policestation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, policestation.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, policestation.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, policestation.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, policestation.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, policestation.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, policestation.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, policestation.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, policestation.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, policestation.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, policestation.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, policestation.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, policestation.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, policestation.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, policestation.NameContainsFold(*i.NameContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, policestation.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, policestation.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, policestation.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, policestation.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, policestation.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, policestation.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, policestation.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, policestation.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, policestation.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, policestation.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, policestation.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, policestation.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, policestation.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Identifier != nil {
		predicates = append(predicates, policestation.IdentifierEQ(*i.Identifier))
	}
	if i.IdentifierNEQ != nil {
		predicates = append(predicates, policestation.IdentifierNEQ(*i.IdentifierNEQ))
	}
	if len(i.IdentifierIn) > 0 {
		predicates = append(predicates, policestation.IdentifierIn(i.IdentifierIn...))
	}
	if len(i.IdentifierNotIn) > 0 {
		predicates = append(predicates, policestation.IdentifierNotIn(i.IdentifierNotIn...))
	}
	if i.IdentifierGT != nil {
		predicates = append(predicates, policestation.IdentifierGT(*i.IdentifierGT))
	}
	if i.IdentifierGTE != nil {
		predicates = append(predicates, policestation.IdentifierGTE(*i.IdentifierGTE))
	}
	if i.IdentifierLT != nil {
		predicates = append(predicates, policestation.IdentifierLT(*i.IdentifierLT))
	}
	if i.IdentifierLTE != nil {
		predicates = append(predicates, policestation.IdentifierLTE(*i.IdentifierLTE))
	}
	if i.IdentifierContains != nil {
		predicates = append(predicates, policestation.IdentifierContains(*i.IdentifierContains))
	}
	if i.IdentifierHasPrefix != nil {
		predicates = append(predicates, policestation.IdentifierHasPrefix(*i.IdentifierHasPrefix))
	}
	if i.IdentifierHasSuffix != nil {
		predicates = append(predicates, policestation.IdentifierHasSuffix(*i.IdentifierHasSuffix))
	}
	if i.IdentifierEqualFold != nil {
		predicates = append(predicates, policestation.IdentifierEqualFold(*i.IdentifierEqualFold))
	}
	if i.IdentifierContainsFold != nil {
		predicates = append(predicates, policestation.IdentifierContainsFold(*i.IdentifierContainsFold))
	}

	if i.HasUsers != nil {
		p := policestation.HasUsers()
		if !*i.HasUsers {
			p = policestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, policestation.HasUsersWith(with...))
	}
	if i.HasParentStation != nil {
		p := policestation.HasParentStation()
		if !*i.HasParentStation {
			p = policestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentStationWith) > 0 {
		with := make([]predicate.PoliceStation, 0, len(i.HasParentStationWith))
		for _, w := range i.HasParentStationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentStationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, policestation.HasParentStationWith(with...))
	}
	if i.HasChildStations != nil {
		p := policestation.HasChildStations()
		if !*i.HasChildStations {
			p = policestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildStationsWith) > 0 {
		with := make([]predicate.PoliceStation, 0, len(i.HasChildStationsWith))
		for _, w := range i.HasChildStationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildStationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, policestation.HasChildStationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPoliceStationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return policestation.And(predicates...), nil
	}
}

// RoleWhereInput represents a where input for filtering Role queries.
type RoleWhereInput struct {
	Predicates []predicate.Role  `json:"-"`
	Not        *RoleWhereInput   `json:"not,omitempty"`
	Or         []*RoleWhereInput `json:"or,omitempty"`
	And        []*RoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "permissions" edge predicates.
	HasPermissions     *bool                   `json:"hasPermissions,omitempty"`
	HasPermissionsWith []*PermissionWhereInput `json:"hasPermissionsWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoleWhereInput) AddPredicates(predicates ...predicate.Role) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoleWhereInput filter on the RoleQuery builder.
func (i *RoleWhereInput) Filter(q *RoleQuery) (*RoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoleWhereInput is returned in case the RoleWhereInput is empty.
var ErrEmptyRoleWhereInput = errors.New("ent: empty predicate RoleWhereInput")

// P returns a predicate for filtering roles.
// An error is returned if the input is empty or invalid.
func (i *RoleWhereInput) P() (predicate.Role, error) {
	var predicates []predicate.Role
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, role.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Role, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, role.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Role, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, role.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, role.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, role.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, role.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, role.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, role.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, role.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, role.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, role.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, role.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, role.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, role.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, role.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, role.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, role.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, role.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, role.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, role.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, role.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, role.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, role.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, role.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasPermissions != nil {
		p := role.HasPermissions()
		if !*i.HasPermissions {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPermissionsWith) > 0 {
		with := make([]predicate.Permission, 0, len(i.HasPermissionsWith))
		for _, w := range i.HasPermissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPermissionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasPermissionsWith(with...))
	}
	if i.HasUsers != nil {
		p := role.HasUsers()
		if !*i.HasUsers {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return role.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "role" edge predicates.
	HasRole     *bool             `json:"hasRole,omitempty"`
	HasRoleWith []*RoleWhereInput `json:"hasRoleWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, user.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, user.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, user.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, user.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, user.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, user.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, user.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, user.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, user.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, user.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, user.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, user.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, user.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, user.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, user.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasRole != nil {
		p := user.HasRole()
		if !*i.HasRole {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoleWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRoleWith))
		for _, w := range i.HasRoleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRoleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
