// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"go-ent-project/internal/ent/camera"
	"go-ent-project/internal/ent/car"
	"go-ent-project/internal/ent/permission"
	"go-ent-project/internal/ent/policestation"
	"go-ent-project/internal/ent/predicate"
	"go-ent-project/internal/ent/role"
	"go-ent-project/internal/ent/user"
	"go-ent-project/internal/ent/vehicledata"
	"time"
)

// CameraWhereInput represents a where input for filtering Camera queries.
type CameraWhereInput struct {
	Predicates []predicate.Camera  `json:"-"`
	Not        *CameraWhereInput   `json:"not,omitempty"`
	Or         []*CameraWhereInput `json:"or,omitempty"`
	And        []*CameraWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "imei" field predicates.
	Imei             *string  `json:"imei,omitempty"`
	ImeiNEQ          *string  `json:"imeiNEQ,omitempty"`
	ImeiIn           []string `json:"imeiIn,omitempty"`
	ImeiNotIn        []string `json:"imeiNotIn,omitempty"`
	ImeiGT           *string  `json:"imeiGT,omitempty"`
	ImeiGTE          *string  `json:"imeiGTE,omitempty"`
	ImeiLT           *string  `json:"imeiLT,omitempty"`
	ImeiLTE          *string  `json:"imeiLTE,omitempty"`
	ImeiContains     *string  `json:"imeiContains,omitempty"`
	ImeiHasPrefix    *string  `json:"imeiHasPrefix,omitempty"`
	ImeiHasSuffix    *string  `json:"imeiHasSuffix,omitempty"`
	ImeiEqualFold    *string  `json:"imeiEqualFold,omitempty"`
	ImeiContainsFold *string  `json:"imeiContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CameraWhereInput) AddPredicates(predicates ...predicate.Camera) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CameraWhereInput filter on the CameraQuery builder.
func (i *CameraWhereInput) Filter(q *CameraQuery) (*CameraQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCameraWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCameraWhereInput is returned in case the CameraWhereInput is empty.
var ErrEmptyCameraWhereInput = errors.New("ent: empty predicate CameraWhereInput")

// P returns a predicate for filtering cameras.
// An error is returned if the input is empty or invalid.
func (i *CameraWhereInput) P() (predicate.Camera, error) {
	var predicates []predicate.Camera
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, camera.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Camera, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, camera.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Camera, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, camera.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, camera.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, camera.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, camera.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, camera.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, camera.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, camera.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, camera.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, camera.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, camera.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, camera.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, camera.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, camera.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, camera.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, camera.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, camera.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, camera.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, camera.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, camera.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, camera.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, camera.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, camera.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, camera.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, camera.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, camera.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, camera.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, camera.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, camera.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, camera.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, camera.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, camera.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, camera.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, camera.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, camera.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, camera.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, camera.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, camera.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, camera.NameContainsFold(*i.NameContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, camera.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, camera.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, camera.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, camera.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, camera.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, camera.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, camera.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, camera.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, camera.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, camera.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, camera.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, camera.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, camera.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Imei != nil {
		predicates = append(predicates, camera.ImeiEQ(*i.Imei))
	}
	if i.ImeiNEQ != nil {
		predicates = append(predicates, camera.ImeiNEQ(*i.ImeiNEQ))
	}
	if len(i.ImeiIn) > 0 {
		predicates = append(predicates, camera.ImeiIn(i.ImeiIn...))
	}
	if len(i.ImeiNotIn) > 0 {
		predicates = append(predicates, camera.ImeiNotIn(i.ImeiNotIn...))
	}
	if i.ImeiGT != nil {
		predicates = append(predicates, camera.ImeiGT(*i.ImeiGT))
	}
	if i.ImeiGTE != nil {
		predicates = append(predicates, camera.ImeiGTE(*i.ImeiGTE))
	}
	if i.ImeiLT != nil {
		predicates = append(predicates, camera.ImeiLT(*i.ImeiLT))
	}
	if i.ImeiLTE != nil {
		predicates = append(predicates, camera.ImeiLTE(*i.ImeiLTE))
	}
	if i.ImeiContains != nil {
		predicates = append(predicates, camera.ImeiContains(*i.ImeiContains))
	}
	if i.ImeiHasPrefix != nil {
		predicates = append(predicates, camera.ImeiHasPrefix(*i.ImeiHasPrefix))
	}
	if i.ImeiHasSuffix != nil {
		predicates = append(predicates, camera.ImeiHasSuffix(*i.ImeiHasSuffix))
	}
	if i.ImeiEqualFold != nil {
		predicates = append(predicates, camera.ImeiEqualFold(*i.ImeiEqualFold))
	}
	if i.ImeiContainsFold != nil {
		predicates = append(predicates, camera.ImeiContainsFold(*i.ImeiContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, camera.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, camera.ActiveNEQ(*i.ActiveNEQ))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCameraWhereInput
	case 1:
		return predicates[0], nil
	default:
		return camera.And(predicates...), nil
	}
}

// CarWhereInput represents a where input for filtering Car queries.
type CarWhereInput struct {
	Predicates []predicate.Car  `json:"-"`
	Not        *CarWhereInput   `json:"not,omitempty"`
	Or         []*CarWhereInput `json:"or,omitempty"`
	And        []*CarWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "make" field predicates.
	Make             *string  `json:"make,omitempty"`
	MakeNEQ          *string  `json:"makeNEQ,omitempty"`
	MakeIn           []string `json:"makeIn,omitempty"`
	MakeNotIn        []string `json:"makeNotIn,omitempty"`
	MakeGT           *string  `json:"makeGT,omitempty"`
	MakeGTE          *string  `json:"makeGTE,omitempty"`
	MakeLT           *string  `json:"makeLT,omitempty"`
	MakeLTE          *string  `json:"makeLTE,omitempty"`
	MakeContains     *string  `json:"makeContains,omitempty"`
	MakeHasPrefix    *string  `json:"makeHasPrefix,omitempty"`
	MakeHasSuffix    *string  `json:"makeHasSuffix,omitempty"`
	MakeEqualFold    *string  `json:"makeEqualFold,omitempty"`
	MakeContainsFold *string  `json:"makeContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "year" field predicates.
	Year      *int  `json:"year,omitempty"`
	YearNEQ   *int  `json:"yearNEQ,omitempty"`
	YearIn    []int `json:"yearIn,omitempty"`
	YearNotIn []int `json:"yearNotIn,omitempty"`
	YearGT    *int  `json:"yearGT,omitempty"`
	YearGTE   *int  `json:"yearGTE,omitempty"`
	YearLT    *int  `json:"yearLT,omitempty"`
	YearLTE   *int  `json:"yearLTE,omitempty"`

	// "registration" field predicates.
	Registration             *string  `json:"registration,omitempty"`
	RegistrationNEQ          *string  `json:"registrationNEQ,omitempty"`
	RegistrationIn           []string `json:"registrationIn,omitempty"`
	RegistrationNotIn        []string `json:"registrationNotIn,omitempty"`
	RegistrationGT           *string  `json:"registrationGT,omitempty"`
	RegistrationGTE          *string  `json:"registrationGTE,omitempty"`
	RegistrationLT           *string  `json:"registrationLT,omitempty"`
	RegistrationLTE          *string  `json:"registrationLTE,omitempty"`
	RegistrationContains     *string  `json:"registrationContains,omitempty"`
	RegistrationHasPrefix    *string  `json:"registrationHasPrefix,omitempty"`
	RegistrationHasSuffix    *string  `json:"registrationHasSuffix,omitempty"`
	RegistrationEqualFold    *string  `json:"registrationEqualFold,omitempty"`
	RegistrationContainsFold *string  `json:"registrationContainsFold,omitempty"`

	// "color" field predicates.
	Color             *string  `json:"color,omitempty"`
	ColorNEQ          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGT           *string  `json:"colorGT,omitempty"`
	ColorGTE          *string  `json:"colorGTE,omitempty"`
	ColorLT           *string  `json:"colorLT,omitempty"`
	ColorLTE          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarWhereInput) AddPredicates(predicates ...predicate.Car) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarWhereInput filter on the CarQuery builder.
func (i *CarWhereInput) Filter(q *CarQuery) (*CarQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarWhereInput is returned in case the CarWhereInput is empty.
var ErrEmptyCarWhereInput = errors.New("ent: empty predicate CarWhereInput")

// P returns a predicate for filtering cars.
// An error is returned if the input is empty or invalid.
func (i *CarWhereInput) P() (predicate.Car, error) {
	var predicates []predicate.Car
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, car.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Car, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, car.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Car, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, car.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, car.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, car.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, car.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, car.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, car.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, car.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, car.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, car.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, car.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, car.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, car.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, car.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, car.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, car.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, car.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, car.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, car.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, car.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, car.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, car.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, car.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, car.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, car.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, car.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Make != nil {
		predicates = append(predicates, car.MakeEQ(*i.Make))
	}
	if i.MakeNEQ != nil {
		predicates = append(predicates, car.MakeNEQ(*i.MakeNEQ))
	}
	if len(i.MakeIn) > 0 {
		predicates = append(predicates, car.MakeIn(i.MakeIn...))
	}
	if len(i.MakeNotIn) > 0 {
		predicates = append(predicates, car.MakeNotIn(i.MakeNotIn...))
	}
	if i.MakeGT != nil {
		predicates = append(predicates, car.MakeGT(*i.MakeGT))
	}
	if i.MakeGTE != nil {
		predicates = append(predicates, car.MakeGTE(*i.MakeGTE))
	}
	if i.MakeLT != nil {
		predicates = append(predicates, car.MakeLT(*i.MakeLT))
	}
	if i.MakeLTE != nil {
		predicates = append(predicates, car.MakeLTE(*i.MakeLTE))
	}
	if i.MakeContains != nil {
		predicates = append(predicates, car.MakeContains(*i.MakeContains))
	}
	if i.MakeHasPrefix != nil {
		predicates = append(predicates, car.MakeHasPrefix(*i.MakeHasPrefix))
	}
	if i.MakeHasSuffix != nil {
		predicates = append(predicates, car.MakeHasSuffix(*i.MakeHasSuffix))
	}
	if i.MakeEqualFold != nil {
		predicates = append(predicates, car.MakeEqualFold(*i.MakeEqualFold))
	}
	if i.MakeContainsFold != nil {
		predicates = append(predicates, car.MakeContainsFold(*i.MakeContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, car.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, car.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, car.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, car.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, car.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, car.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, car.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, car.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, car.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, car.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, car.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, car.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, car.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Year != nil {
		predicates = append(predicates, car.YearEQ(*i.Year))
	}
	if i.YearNEQ != nil {
		predicates = append(predicates, car.YearNEQ(*i.YearNEQ))
	}
	if len(i.YearIn) > 0 {
		predicates = append(predicates, car.YearIn(i.YearIn...))
	}
	if len(i.YearNotIn) > 0 {
		predicates = append(predicates, car.YearNotIn(i.YearNotIn...))
	}
	if i.YearGT != nil {
		predicates = append(predicates, car.YearGT(*i.YearGT))
	}
	if i.YearGTE != nil {
		predicates = append(predicates, car.YearGTE(*i.YearGTE))
	}
	if i.YearLT != nil {
		predicates = append(predicates, car.YearLT(*i.YearLT))
	}
	if i.YearLTE != nil {
		predicates = append(predicates, car.YearLTE(*i.YearLTE))
	}
	if i.Registration != nil {
		predicates = append(predicates, car.RegistrationEQ(*i.Registration))
	}
	if i.RegistrationNEQ != nil {
		predicates = append(predicates, car.RegistrationNEQ(*i.RegistrationNEQ))
	}
	if len(i.RegistrationIn) > 0 {
		predicates = append(predicates, car.RegistrationIn(i.RegistrationIn...))
	}
	if len(i.RegistrationNotIn) > 0 {
		predicates = append(predicates, car.RegistrationNotIn(i.RegistrationNotIn...))
	}
	if i.RegistrationGT != nil {
		predicates = append(predicates, car.RegistrationGT(*i.RegistrationGT))
	}
	if i.RegistrationGTE != nil {
		predicates = append(predicates, car.RegistrationGTE(*i.RegistrationGTE))
	}
	if i.RegistrationLT != nil {
		predicates = append(predicates, car.RegistrationLT(*i.RegistrationLT))
	}
	if i.RegistrationLTE != nil {
		predicates = append(predicates, car.RegistrationLTE(*i.RegistrationLTE))
	}
	if i.RegistrationContains != nil {
		predicates = append(predicates, car.RegistrationContains(*i.RegistrationContains))
	}
	if i.RegistrationHasPrefix != nil {
		predicates = append(predicates, car.RegistrationHasPrefix(*i.RegistrationHasPrefix))
	}
	if i.RegistrationHasSuffix != nil {
		predicates = append(predicates, car.RegistrationHasSuffix(*i.RegistrationHasSuffix))
	}
	if i.RegistrationEqualFold != nil {
		predicates = append(predicates, car.RegistrationEqualFold(*i.RegistrationEqualFold))
	}
	if i.RegistrationContainsFold != nil {
		predicates = append(predicates, car.RegistrationContainsFold(*i.RegistrationContainsFold))
	}
	if i.Color != nil {
		predicates = append(predicates, car.ColorEQ(*i.Color))
	}
	if i.ColorNEQ != nil {
		predicates = append(predicates, car.ColorNEQ(*i.ColorNEQ))
	}
	if len(i.ColorIn) > 0 {
		predicates = append(predicates, car.ColorIn(i.ColorIn...))
	}
	if len(i.ColorNotIn) > 0 {
		predicates = append(predicates, car.ColorNotIn(i.ColorNotIn...))
	}
	if i.ColorGT != nil {
		predicates = append(predicates, car.ColorGT(*i.ColorGT))
	}
	if i.ColorGTE != nil {
		predicates = append(predicates, car.ColorGTE(*i.ColorGTE))
	}
	if i.ColorLT != nil {
		predicates = append(predicates, car.ColorLT(*i.ColorLT))
	}
	if i.ColorLTE != nil {
		predicates = append(predicates, car.ColorLTE(*i.ColorLTE))
	}
	if i.ColorContains != nil {
		predicates = append(predicates, car.ColorContains(*i.ColorContains))
	}
	if i.ColorHasPrefix != nil {
		predicates = append(predicates, car.ColorHasPrefix(*i.ColorHasPrefix))
	}
	if i.ColorHasSuffix != nil {
		predicates = append(predicates, car.ColorHasSuffix(*i.ColorHasSuffix))
	}
	if i.ColorEqualFold != nil {
		predicates = append(predicates, car.ColorEqualFold(*i.ColorEqualFold))
	}
	if i.ColorContainsFold != nil {
		predicates = append(predicates, car.ColorContainsFold(*i.ColorContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarWhereInput
	case 1:
		return predicates[0], nil
	default:
		return car.And(predicates...), nil
	}
}

// PermissionWhereInput represents a where input for filtering Permission queries.
type PermissionWhereInput struct {
	Predicates []predicate.Permission  `json:"-"`
	Not        *PermissionWhereInput   `json:"not,omitempty"`
	Or         []*PermissionWhereInput `json:"or,omitempty"`
	And        []*PermissionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "can_read" field predicates.
	CanRead    *bool `json:"canRead,omitempty"`
	CanReadNEQ *bool `json:"canReadNEQ,omitempty"`

	// "can_create" field predicates.
	CanCreate    *bool `json:"canCreate,omitempty"`
	CanCreateNEQ *bool `json:"canCreateNEQ,omitempty"`

	// "can_update" field predicates.
	CanUpdate    *bool `json:"canUpdate,omitempty"`
	CanUpdateNEQ *bool `json:"canUpdateNEQ,omitempty"`

	// "can_delete" field predicates.
	CanDelete    *bool `json:"canDelete,omitempty"`
	CanDeleteNEQ *bool `json:"canDeleteNEQ,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PermissionWhereInput) AddPredicates(predicates ...predicate.Permission) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PermissionWhereInput filter on the PermissionQuery builder.
func (i *PermissionWhereInput) Filter(q *PermissionQuery) (*PermissionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPermissionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPermissionWhereInput is returned in case the PermissionWhereInput is empty.
var ErrEmptyPermissionWhereInput = errors.New("ent: empty predicate PermissionWhereInput")

// P returns a predicate for filtering permissions.
// An error is returned if the input is empty or invalid.
func (i *PermissionWhereInput) P() (predicate.Permission, error) {
	var predicates []predicate.Permission
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, permission.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Permission, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, permission.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Permission, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, permission.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, permission.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, permission.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, permission.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, permission.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, permission.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, permission.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, permission.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, permission.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, permission.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, permission.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, permission.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, permission.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, permission.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, permission.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, permission.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, permission.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, permission.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, permission.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, permission.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, permission.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, permission.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, permission.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, permission.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, permission.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, permission.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, permission.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, permission.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, permission.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, permission.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, permission.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, permission.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, permission.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, permission.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, permission.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, permission.NameContainsFold(*i.NameContainsFold))
	}
	if i.CanRead != nil {
		predicates = append(predicates, permission.CanReadEQ(*i.CanRead))
	}
	if i.CanReadNEQ != nil {
		predicates = append(predicates, permission.CanReadNEQ(*i.CanReadNEQ))
	}
	if i.CanCreate != nil {
		predicates = append(predicates, permission.CanCreateEQ(*i.CanCreate))
	}
	if i.CanCreateNEQ != nil {
		predicates = append(predicates, permission.CanCreateNEQ(*i.CanCreateNEQ))
	}
	if i.CanUpdate != nil {
		predicates = append(predicates, permission.CanUpdateEQ(*i.CanUpdate))
	}
	if i.CanUpdateNEQ != nil {
		predicates = append(predicates, permission.CanUpdateNEQ(*i.CanUpdateNEQ))
	}
	if i.CanDelete != nil {
		predicates = append(predicates, permission.CanDeleteEQ(*i.CanDelete))
	}
	if i.CanDeleteNEQ != nil {
		predicates = append(predicates, permission.CanDeleteNEQ(*i.CanDeleteNEQ))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPermissionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return permission.And(predicates...), nil
	}
}

// PoliceStationWhereInput represents a where input for filtering PoliceStation queries.
type PoliceStationWhereInput struct {
	Predicates []predicate.PoliceStation  `json:"-"`
	Not        *PoliceStationWhereInput   `json:"not,omitempty"`
	Or         []*PoliceStationWhereInput `json:"or,omitempty"`
	And        []*PoliceStationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "identifier" field predicates.
	Identifier             *string  `json:"identifier,omitempty"`
	IdentifierNEQ          *string  `json:"identifierNEQ,omitempty"`
	IdentifierIn           []string `json:"identifierIn,omitempty"`
	IdentifierNotIn        []string `json:"identifierNotIn,omitempty"`
	IdentifierGT           *string  `json:"identifierGT,omitempty"`
	IdentifierGTE          *string  `json:"identifierGTE,omitempty"`
	IdentifierLT           *string  `json:"identifierLT,omitempty"`
	IdentifierLTE          *string  `json:"identifierLTE,omitempty"`
	IdentifierContains     *string  `json:"identifierContains,omitempty"`
	IdentifierHasPrefix    *string  `json:"identifierHasPrefix,omitempty"`
	IdentifierHasSuffix    *string  `json:"identifierHasSuffix,omitempty"`
	IdentifierEqualFold    *string  `json:"identifierEqualFold,omitempty"`
	IdentifierContainsFold *string  `json:"identifierContainsFold,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "parent_station" edge predicates.
	HasParentStation     *bool                      `json:"hasParentStation,omitempty"`
	HasParentStationWith []*PoliceStationWhereInput `json:"hasParentStationWith,omitempty"`

	// "child_stations" edge predicates.
	HasChildStations     *bool                      `json:"hasChildStations,omitempty"`
	HasChildStationsWith []*PoliceStationWhereInput `json:"hasChildStationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PoliceStationWhereInput) AddPredicates(predicates ...predicate.PoliceStation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PoliceStationWhereInput filter on the PoliceStationQuery builder.
func (i *PoliceStationWhereInput) Filter(q *PoliceStationQuery) (*PoliceStationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPoliceStationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPoliceStationWhereInput is returned in case the PoliceStationWhereInput is empty.
var ErrEmptyPoliceStationWhereInput = errors.New("ent: empty predicate PoliceStationWhereInput")

// P returns a predicate for filtering policestations.
// An error is returned if the input is empty or invalid.
func (i *PoliceStationWhereInput) P() (predicate.PoliceStation, error) {
	var predicates []predicate.PoliceStation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, policestation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PoliceStation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, policestation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PoliceStation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, policestation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, policestation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, policestation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, policestation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, policestation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, policestation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, policestation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, policestation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, policestation.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, policestation.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, policestation.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, policestation.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, policestation.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, policestation.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, policestation.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, policestation.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, policestation.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, policestation.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, policestation.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, policestation.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, policestation.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, policestation.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, policestation.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, policestation.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, policestation.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, policestation.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, policestation.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, policestation.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, policestation.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, policestation.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, policestation.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, policestation.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, policestation.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, policestation.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, policestation.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, policestation.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, policestation.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, policestation.NameContainsFold(*i.NameContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, policestation.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, policestation.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, policestation.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, policestation.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, policestation.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, policestation.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, policestation.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, policestation.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, policestation.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, policestation.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, policestation.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, policestation.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, policestation.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Identifier != nil {
		predicates = append(predicates, policestation.IdentifierEQ(*i.Identifier))
	}
	if i.IdentifierNEQ != nil {
		predicates = append(predicates, policestation.IdentifierNEQ(*i.IdentifierNEQ))
	}
	if len(i.IdentifierIn) > 0 {
		predicates = append(predicates, policestation.IdentifierIn(i.IdentifierIn...))
	}
	if len(i.IdentifierNotIn) > 0 {
		predicates = append(predicates, policestation.IdentifierNotIn(i.IdentifierNotIn...))
	}
	if i.IdentifierGT != nil {
		predicates = append(predicates, policestation.IdentifierGT(*i.IdentifierGT))
	}
	if i.IdentifierGTE != nil {
		predicates = append(predicates, policestation.IdentifierGTE(*i.IdentifierGTE))
	}
	if i.IdentifierLT != nil {
		predicates = append(predicates, policestation.IdentifierLT(*i.IdentifierLT))
	}
	if i.IdentifierLTE != nil {
		predicates = append(predicates, policestation.IdentifierLTE(*i.IdentifierLTE))
	}
	if i.IdentifierContains != nil {
		predicates = append(predicates, policestation.IdentifierContains(*i.IdentifierContains))
	}
	if i.IdentifierHasPrefix != nil {
		predicates = append(predicates, policestation.IdentifierHasPrefix(*i.IdentifierHasPrefix))
	}
	if i.IdentifierHasSuffix != nil {
		predicates = append(predicates, policestation.IdentifierHasSuffix(*i.IdentifierHasSuffix))
	}
	if i.IdentifierEqualFold != nil {
		predicates = append(predicates, policestation.IdentifierEqualFold(*i.IdentifierEqualFold))
	}
	if i.IdentifierContainsFold != nil {
		predicates = append(predicates, policestation.IdentifierContainsFold(*i.IdentifierContainsFold))
	}

	if i.HasUsers != nil {
		p := policestation.HasUsers()
		if !*i.HasUsers {
			p = policestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, policestation.HasUsersWith(with...))
	}
	if i.HasParentStation != nil {
		p := policestation.HasParentStation()
		if !*i.HasParentStation {
			p = policestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentStationWith) > 0 {
		with := make([]predicate.PoliceStation, 0, len(i.HasParentStationWith))
		for _, w := range i.HasParentStationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentStationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, policestation.HasParentStationWith(with...))
	}
	if i.HasChildStations != nil {
		p := policestation.HasChildStations()
		if !*i.HasChildStations {
			p = policestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildStationsWith) > 0 {
		with := make([]predicate.PoliceStation, 0, len(i.HasChildStationsWith))
		for _, w := range i.HasChildStationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildStationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, policestation.HasChildStationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPoliceStationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return policestation.And(predicates...), nil
	}
}

// RoleWhereInput represents a where input for filtering Role queries.
type RoleWhereInput struct {
	Predicates []predicate.Role  `json:"-"`
	Not        *RoleWhereInput   `json:"not,omitempty"`
	Or         []*RoleWhereInput `json:"or,omitempty"`
	And        []*RoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "permissions" edge predicates.
	HasPermissions     *bool                   `json:"hasPermissions,omitempty"`
	HasPermissionsWith []*PermissionWhereInput `json:"hasPermissionsWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoleWhereInput) AddPredicates(predicates ...predicate.Role) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoleWhereInput filter on the RoleQuery builder.
func (i *RoleWhereInput) Filter(q *RoleQuery) (*RoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoleWhereInput is returned in case the RoleWhereInput is empty.
var ErrEmptyRoleWhereInput = errors.New("ent: empty predicate RoleWhereInput")

// P returns a predicate for filtering roles.
// An error is returned if the input is empty or invalid.
func (i *RoleWhereInput) P() (predicate.Role, error) {
	var predicates []predicate.Role
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, role.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Role, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, role.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Role, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, role.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, role.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, role.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, role.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, role.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, role.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, role.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, role.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, role.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, role.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, role.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, role.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, role.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, role.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, role.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, role.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, role.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, role.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, role.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, role.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, role.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, role.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, role.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, role.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, role.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, role.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, role.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, role.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, role.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, role.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, role.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, role.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, role.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, role.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, role.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, role.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, role.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, role.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasPermissions != nil {
		p := role.HasPermissions()
		if !*i.HasPermissions {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPermissionsWith) > 0 {
		with := make([]predicate.Permission, 0, len(i.HasPermissionsWith))
		for _, w := range i.HasPermissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPermissionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasPermissionsWith(with...))
	}
	if i.HasUsers != nil {
		p := role.HasUsers()
		if !*i.HasUsers {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return role.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "role_id" field predicates.
	RoleID       *int  `json:"roleID,omitempty"`
	RoleIDNEQ    *int  `json:"roleIDNEQ,omitempty"`
	RoleIDIn     []int `json:"roleIDIn,omitempty"`
	RoleIDNotIn  []int `json:"roleIDNotIn,omitempty"`
	RoleIDIsNil  bool  `json:"roleIDIsNil,omitempty"`
	RoleIDNotNil bool  `json:"roleIDNotNil,omitempty"`

	// "role" edge predicates.
	HasRole     *bool             `json:"hasRole,omitempty"`
	HasRoleWith []*RoleWhereInput `json:"hasRoleWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, user.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, user.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, user.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, user.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, user.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, user.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, user.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, user.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, user.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, user.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, user.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, user.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, user.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, user.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, user.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, user.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, user.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.RoleID != nil {
		predicates = append(predicates, user.RoleIDEQ(*i.RoleID))
	}
	if i.RoleIDNEQ != nil {
		predicates = append(predicates, user.RoleIDNEQ(*i.RoleIDNEQ))
	}
	if len(i.RoleIDIn) > 0 {
		predicates = append(predicates, user.RoleIDIn(i.RoleIDIn...))
	}
	if len(i.RoleIDNotIn) > 0 {
		predicates = append(predicates, user.RoleIDNotIn(i.RoleIDNotIn...))
	}
	if i.RoleIDIsNil {
		predicates = append(predicates, user.RoleIDIsNil())
	}
	if i.RoleIDNotNil {
		predicates = append(predicates, user.RoleIDNotNil())
	}

	if i.HasRole != nil {
		p := user.HasRole()
		if !*i.HasRole {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoleWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRoleWith))
		for _, w := range i.HasRoleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRoleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// VehicleDataWhereInput represents a where input for filtering VehicleData queries.
type VehicleDataWhereInput struct {
	Predicates []predicate.VehicleData  `json:"-"`
	Not        *VehicleDataWhereInput   `json:"not,omitempty"`
	Or         []*VehicleDataWhereInput `json:"or,omitempty"`
	And        []*VehicleDataWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "plate_channel" field predicates.
	PlateChannel       *int  `json:"plateChannel,omitempty"`
	PlateChannelNEQ    *int  `json:"plateChannelNEQ,omitempty"`
	PlateChannelIn     []int `json:"plateChannelIn,omitempty"`
	PlateChannelNotIn  []int `json:"plateChannelNotIn,omitempty"`
	PlateChannelGT     *int  `json:"plateChannelGT,omitempty"`
	PlateChannelGTE    *int  `json:"plateChannelGTE,omitempty"`
	PlateChannelLT     *int  `json:"plateChannelLT,omitempty"`
	PlateChannelLTE    *int  `json:"plateChannelLTE,omitempty"`
	PlateChannelIsNil  bool  `json:"plateChannelIsNil,omitempty"`
	PlateChannelNotNil bool  `json:"plateChannelNotNil,omitempty"`

	// "plate_is_exist" field predicates.
	PlateIsExist       *bool `json:"plateIsExist,omitempty"`
	PlateIsExistNEQ    *bool `json:"plateIsExistNEQ,omitempty"`
	PlateIsExistIsNil  bool  `json:"plateIsExistIsNil,omitempty"`
	PlateIsExistNotNil bool  `json:"plateIsExistNotNil,omitempty"`

	// "plate_color" field predicates.
	PlateColor             *string  `json:"plateColor,omitempty"`
	PlateColorNEQ          *string  `json:"plateColorNEQ,omitempty"`
	PlateColorIn           []string `json:"plateColorIn,omitempty"`
	PlateColorNotIn        []string `json:"plateColorNotIn,omitempty"`
	PlateColorGT           *string  `json:"plateColorGT,omitempty"`
	PlateColorGTE          *string  `json:"plateColorGTE,omitempty"`
	PlateColorLT           *string  `json:"plateColorLT,omitempty"`
	PlateColorLTE          *string  `json:"plateColorLTE,omitempty"`
	PlateColorContains     *string  `json:"plateColorContains,omitempty"`
	PlateColorHasPrefix    *string  `json:"plateColorHasPrefix,omitempty"`
	PlateColorHasSuffix    *string  `json:"plateColorHasSuffix,omitempty"`
	PlateColorIsNil        bool     `json:"plateColorIsNil,omitempty"`
	PlateColorNotNil       bool     `json:"plateColorNotNil,omitempty"`
	PlateColorEqualFold    *string  `json:"plateColorEqualFold,omitempty"`
	PlateColorContainsFold *string  `json:"plateColorContainsFold,omitempty"`

	// "plate_number" field predicates.
	PlateNumber             *string  `json:"plateNumber,omitempty"`
	PlateNumberNEQ          *string  `json:"plateNumberNEQ,omitempty"`
	PlateNumberIn           []string `json:"plateNumberIn,omitempty"`
	PlateNumberNotIn        []string `json:"plateNumberNotIn,omitempty"`
	PlateNumberGT           *string  `json:"plateNumberGT,omitempty"`
	PlateNumberGTE          *string  `json:"plateNumberGTE,omitempty"`
	PlateNumberLT           *string  `json:"plateNumberLT,omitempty"`
	PlateNumberLTE          *string  `json:"plateNumberLTE,omitempty"`
	PlateNumberContains     *string  `json:"plateNumberContains,omitempty"`
	PlateNumberHasPrefix    *string  `json:"plateNumberHasPrefix,omitempty"`
	PlateNumberHasSuffix    *string  `json:"plateNumberHasSuffix,omitempty"`
	PlateNumberIsNil        bool     `json:"plateNumberIsNil,omitempty"`
	PlateNumberNotNil       bool     `json:"plateNumberNotNil,omitempty"`
	PlateNumberEqualFold    *string  `json:"plateNumberEqualFold,omitempty"`
	PlateNumberContainsFold *string  `json:"plateNumberContainsFold,omitempty"`

	// "plate_type" field predicates.
	PlateType             *string  `json:"plateType,omitempty"`
	PlateTypeNEQ          *string  `json:"plateTypeNEQ,omitempty"`
	PlateTypeIn           []string `json:"plateTypeIn,omitempty"`
	PlateTypeNotIn        []string `json:"plateTypeNotIn,omitempty"`
	PlateTypeGT           *string  `json:"plateTypeGT,omitempty"`
	PlateTypeGTE          *string  `json:"plateTypeGTE,omitempty"`
	PlateTypeLT           *string  `json:"plateTypeLT,omitempty"`
	PlateTypeLTE          *string  `json:"plateTypeLTE,omitempty"`
	PlateTypeContains     *string  `json:"plateTypeContains,omitempty"`
	PlateTypeHasPrefix    *string  `json:"plateTypeHasPrefix,omitempty"`
	PlateTypeHasSuffix    *string  `json:"plateTypeHasSuffix,omitempty"`
	PlateTypeIsNil        bool     `json:"plateTypeIsNil,omitempty"`
	PlateTypeNotNil       bool     `json:"plateTypeNotNil,omitempty"`
	PlateTypeEqualFold    *string  `json:"plateTypeEqualFold,omitempty"`
	PlateTypeContainsFold *string  `json:"plateTypeContainsFold,omitempty"`

	// "plate_region" field predicates.
	PlateRegion             *string  `json:"plateRegion,omitempty"`
	PlateRegionNEQ          *string  `json:"plateRegionNEQ,omitempty"`
	PlateRegionIn           []string `json:"plateRegionIn,omitempty"`
	PlateRegionNotIn        []string `json:"plateRegionNotIn,omitempty"`
	PlateRegionGT           *string  `json:"plateRegionGT,omitempty"`
	PlateRegionGTE          *string  `json:"plateRegionGTE,omitempty"`
	PlateRegionLT           *string  `json:"plateRegionLT,omitempty"`
	PlateRegionLTE          *string  `json:"plateRegionLTE,omitempty"`
	PlateRegionContains     *string  `json:"plateRegionContains,omitempty"`
	PlateRegionHasPrefix    *string  `json:"plateRegionHasPrefix,omitempty"`
	PlateRegionHasSuffix    *string  `json:"plateRegionHasSuffix,omitempty"`
	PlateRegionIsNil        bool     `json:"plateRegionIsNil,omitempty"`
	PlateRegionNotNil       bool     `json:"plateRegionNotNil,omitempty"`
	PlateRegionEqualFold    *string  `json:"plateRegionEqualFold,omitempty"`
	PlateRegionContainsFold *string  `json:"plateRegionContainsFold,omitempty"`

	// "plate_upload_num" field predicates.
	PlateUploadNum       *int  `json:"plateUploadNum,omitempty"`
	PlateUploadNumNEQ    *int  `json:"plateUploadNumNEQ,omitempty"`
	PlateUploadNumIn     []int `json:"plateUploadNumIn,omitempty"`
	PlateUploadNumNotIn  []int `json:"plateUploadNumNotIn,omitempty"`
	PlateUploadNumGT     *int  `json:"plateUploadNumGT,omitempty"`
	PlateUploadNumGTE    *int  `json:"plateUploadNumGTE,omitempty"`
	PlateUploadNumLT     *int  `json:"plateUploadNumLT,omitempty"`
	PlateUploadNumLTE    *int  `json:"plateUploadNumLTE,omitempty"`
	PlateUploadNumIsNil  bool  `json:"plateUploadNumIsNil,omitempty"`
	PlateUploadNumNotNil bool  `json:"plateUploadNumNotNil,omitempty"`

	// "snap_allow_user" field predicates.
	SnapAllowUser       *bool `json:"snapAllowUser,omitempty"`
	SnapAllowUserNEQ    *bool `json:"snapAllowUserNEQ,omitempty"`
	SnapAllowUserIsNil  bool  `json:"snapAllowUserIsNil,omitempty"`
	SnapAllowUserNotNil bool  `json:"snapAllowUserNotNil,omitempty"`

	// "snap_allow_user_end_time" field predicates.
	SnapAllowUserEndTime             *string  `json:"snapAllowUserEndTime,omitempty"`
	SnapAllowUserEndTimeNEQ          *string  `json:"snapAllowUserEndTimeNEQ,omitempty"`
	SnapAllowUserEndTimeIn           []string `json:"snapAllowUserEndTimeIn,omitempty"`
	SnapAllowUserEndTimeNotIn        []string `json:"snapAllowUserEndTimeNotIn,omitempty"`
	SnapAllowUserEndTimeGT           *string  `json:"snapAllowUserEndTimeGT,omitempty"`
	SnapAllowUserEndTimeGTE          *string  `json:"snapAllowUserEndTimeGTE,omitempty"`
	SnapAllowUserEndTimeLT           *string  `json:"snapAllowUserEndTimeLT,omitempty"`
	SnapAllowUserEndTimeLTE          *string  `json:"snapAllowUserEndTimeLTE,omitempty"`
	SnapAllowUserEndTimeContains     *string  `json:"snapAllowUserEndTimeContains,omitempty"`
	SnapAllowUserEndTimeHasPrefix    *string  `json:"snapAllowUserEndTimeHasPrefix,omitempty"`
	SnapAllowUserEndTimeHasSuffix    *string  `json:"snapAllowUserEndTimeHasSuffix,omitempty"`
	SnapAllowUserEndTimeIsNil        bool     `json:"snapAllowUserEndTimeIsNil,omitempty"`
	SnapAllowUserEndTimeNotNil       bool     `json:"snapAllowUserEndTimeNotNil,omitempty"`
	SnapAllowUserEndTimeEqualFold    *string  `json:"snapAllowUserEndTimeEqualFold,omitempty"`
	SnapAllowUserEndTimeContainsFold *string  `json:"snapAllowUserEndTimeContainsFold,omitempty"`

	// "snap_defence_code" field predicates.
	SnapDefenceCode             *string  `json:"snapDefenceCode,omitempty"`
	SnapDefenceCodeNEQ          *string  `json:"snapDefenceCodeNEQ,omitempty"`
	SnapDefenceCodeIn           []string `json:"snapDefenceCodeIn,omitempty"`
	SnapDefenceCodeNotIn        []string `json:"snapDefenceCodeNotIn,omitempty"`
	SnapDefenceCodeGT           *string  `json:"snapDefenceCodeGT,omitempty"`
	SnapDefenceCodeGTE          *string  `json:"snapDefenceCodeGTE,omitempty"`
	SnapDefenceCodeLT           *string  `json:"snapDefenceCodeLT,omitempty"`
	SnapDefenceCodeLTE          *string  `json:"snapDefenceCodeLTE,omitempty"`
	SnapDefenceCodeContains     *string  `json:"snapDefenceCodeContains,omitempty"`
	SnapDefenceCodeHasPrefix    *string  `json:"snapDefenceCodeHasPrefix,omitempty"`
	SnapDefenceCodeHasSuffix    *string  `json:"snapDefenceCodeHasSuffix,omitempty"`
	SnapDefenceCodeIsNil        bool     `json:"snapDefenceCodeIsNil,omitempty"`
	SnapDefenceCodeNotNil       bool     `json:"snapDefenceCodeNotNil,omitempty"`
	SnapDefenceCodeEqualFold    *string  `json:"snapDefenceCodeEqualFold,omitempty"`
	SnapDefenceCodeContainsFold *string  `json:"snapDefenceCodeContainsFold,omitempty"`

	// "snap_device_id" field predicates.
	SnapDeviceID             *string  `json:"snapDeviceID,omitempty"`
	SnapDeviceIDNEQ          *string  `json:"snapDeviceIDNEQ,omitempty"`
	SnapDeviceIDIn           []string `json:"snapDeviceIDIn,omitempty"`
	SnapDeviceIDNotIn        []string `json:"snapDeviceIDNotIn,omitempty"`
	SnapDeviceIDGT           *string  `json:"snapDeviceIDGT,omitempty"`
	SnapDeviceIDGTE          *string  `json:"snapDeviceIDGTE,omitempty"`
	SnapDeviceIDLT           *string  `json:"snapDeviceIDLT,omitempty"`
	SnapDeviceIDLTE          *string  `json:"snapDeviceIDLTE,omitempty"`
	SnapDeviceIDContains     *string  `json:"snapDeviceIDContains,omitempty"`
	SnapDeviceIDHasPrefix    *string  `json:"snapDeviceIDHasPrefix,omitempty"`
	SnapDeviceIDHasSuffix    *string  `json:"snapDeviceIDHasSuffix,omitempty"`
	SnapDeviceIDIsNil        bool     `json:"snapDeviceIDIsNil,omitempty"`
	SnapDeviceIDNotNil       bool     `json:"snapDeviceIDNotNil,omitempty"`
	SnapDeviceIDEqualFold    *string  `json:"snapDeviceIDEqualFold,omitempty"`
	SnapDeviceIDContainsFold *string  `json:"snapDeviceIDContainsFold,omitempty"`

	// "snap_in_car_people_num" field predicates.
	SnapInCarPeopleNum       *int  `json:"snapInCarPeopleNum,omitempty"`
	SnapInCarPeopleNumNEQ    *int  `json:"snapInCarPeopleNumNEQ,omitempty"`
	SnapInCarPeopleNumIn     []int `json:"snapInCarPeopleNumIn,omitempty"`
	SnapInCarPeopleNumNotIn  []int `json:"snapInCarPeopleNumNotIn,omitempty"`
	SnapInCarPeopleNumGT     *int  `json:"snapInCarPeopleNumGT,omitempty"`
	SnapInCarPeopleNumGTE    *int  `json:"snapInCarPeopleNumGTE,omitempty"`
	SnapInCarPeopleNumLT     *int  `json:"snapInCarPeopleNumLT,omitempty"`
	SnapInCarPeopleNumLTE    *int  `json:"snapInCarPeopleNumLTE,omitempty"`
	SnapInCarPeopleNumIsNil  bool  `json:"snapInCarPeopleNumIsNil,omitempty"`
	SnapInCarPeopleNumNotNil bool  `json:"snapInCarPeopleNumNotNil,omitempty"`

	// "snap_lan_no" field predicates.
	SnapLanNo       *int  `json:"snapLanNo,omitempty"`
	SnapLanNoNEQ    *int  `json:"snapLanNoNEQ,omitempty"`
	SnapLanNoIn     []int `json:"snapLanNoIn,omitempty"`
	SnapLanNoNotIn  []int `json:"snapLanNoNotIn,omitempty"`
	SnapLanNoGT     *int  `json:"snapLanNoGT,omitempty"`
	SnapLanNoGTE    *int  `json:"snapLanNoGTE,omitempty"`
	SnapLanNoLT     *int  `json:"snapLanNoLT,omitempty"`
	SnapLanNoLTE    *int  `json:"snapLanNoLTE,omitempty"`
	SnapLanNoIsNil  bool  `json:"snapLanNoIsNil,omitempty"`
	SnapLanNoNotNil bool  `json:"snapLanNoNotNil,omitempty"`

	// "snap_open_strobe" field predicates.
	SnapOpenStrobe       *bool `json:"snapOpenStrobe,omitempty"`
	SnapOpenStrobeNEQ    *bool `json:"snapOpenStrobeNEQ,omitempty"`
	SnapOpenStrobeIsNil  bool  `json:"snapOpenStrobeIsNil,omitempty"`
	SnapOpenStrobeNotNil bool  `json:"snapOpenStrobeNotNil,omitempty"`

	// "vehicle_series" field predicates.
	VehicleSeries             *string  `json:"vehicleSeries,omitempty"`
	VehicleSeriesNEQ          *string  `json:"vehicleSeriesNEQ,omitempty"`
	VehicleSeriesIn           []string `json:"vehicleSeriesIn,omitempty"`
	VehicleSeriesNotIn        []string `json:"vehicleSeriesNotIn,omitempty"`
	VehicleSeriesGT           *string  `json:"vehicleSeriesGT,omitempty"`
	VehicleSeriesGTE          *string  `json:"vehicleSeriesGTE,omitempty"`
	VehicleSeriesLT           *string  `json:"vehicleSeriesLT,omitempty"`
	VehicleSeriesLTE          *string  `json:"vehicleSeriesLTE,omitempty"`
	VehicleSeriesContains     *string  `json:"vehicleSeriesContains,omitempty"`
	VehicleSeriesHasPrefix    *string  `json:"vehicleSeriesHasPrefix,omitempty"`
	VehicleSeriesHasSuffix    *string  `json:"vehicleSeriesHasSuffix,omitempty"`
	VehicleSeriesIsNil        bool     `json:"vehicleSeriesIsNil,omitempty"`
	VehicleSeriesNotNil       bool     `json:"vehicleSeriesNotNil,omitempty"`
	VehicleSeriesEqualFold    *string  `json:"vehicleSeriesEqualFold,omitempty"`
	VehicleSeriesContainsFold *string  `json:"vehicleSeriesContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *VehicleDataWhereInput) AddPredicates(predicates ...predicate.VehicleData) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the VehicleDataWhereInput filter on the VehicleDataQuery builder.
func (i *VehicleDataWhereInput) Filter(q *VehicleDataQuery) (*VehicleDataQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyVehicleDataWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyVehicleDataWhereInput is returned in case the VehicleDataWhereInput is empty.
var ErrEmptyVehicleDataWhereInput = errors.New("ent: empty predicate VehicleDataWhereInput")

// P returns a predicate for filtering vehicledataslice.
// An error is returned if the input is empty or invalid.
func (i *VehicleDataWhereInput) P() (predicate.VehicleData, error) {
	var predicates []predicate.VehicleData
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, vehicledata.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.VehicleData, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, vehicledata.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.VehicleData, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, vehicledata.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, vehicledata.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, vehicledata.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, vehicledata.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, vehicledata.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, vehicledata.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, vehicledata.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, vehicledata.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, vehicledata.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, vehicledata.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, vehicledata.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, vehicledata.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, vehicledata.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, vehicledata.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, vehicledata.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, vehicledata.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, vehicledata.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, vehicledata.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, vehicledata.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, vehicledata.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, vehicledata.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, vehicledata.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, vehicledata.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, vehicledata.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, vehicledata.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.PlateChannel != nil {
		predicates = append(predicates, vehicledata.PlateChannelEQ(*i.PlateChannel))
	}
	if i.PlateChannelNEQ != nil {
		predicates = append(predicates, vehicledata.PlateChannelNEQ(*i.PlateChannelNEQ))
	}
	if len(i.PlateChannelIn) > 0 {
		predicates = append(predicates, vehicledata.PlateChannelIn(i.PlateChannelIn...))
	}
	if len(i.PlateChannelNotIn) > 0 {
		predicates = append(predicates, vehicledata.PlateChannelNotIn(i.PlateChannelNotIn...))
	}
	if i.PlateChannelGT != nil {
		predicates = append(predicates, vehicledata.PlateChannelGT(*i.PlateChannelGT))
	}
	if i.PlateChannelGTE != nil {
		predicates = append(predicates, vehicledata.PlateChannelGTE(*i.PlateChannelGTE))
	}
	if i.PlateChannelLT != nil {
		predicates = append(predicates, vehicledata.PlateChannelLT(*i.PlateChannelLT))
	}
	if i.PlateChannelLTE != nil {
		predicates = append(predicates, vehicledata.PlateChannelLTE(*i.PlateChannelLTE))
	}
	if i.PlateChannelIsNil {
		predicates = append(predicates, vehicledata.PlateChannelIsNil())
	}
	if i.PlateChannelNotNil {
		predicates = append(predicates, vehicledata.PlateChannelNotNil())
	}
	if i.PlateIsExist != nil {
		predicates = append(predicates, vehicledata.PlateIsExistEQ(*i.PlateIsExist))
	}
	if i.PlateIsExistNEQ != nil {
		predicates = append(predicates, vehicledata.PlateIsExistNEQ(*i.PlateIsExistNEQ))
	}
	if i.PlateIsExistIsNil {
		predicates = append(predicates, vehicledata.PlateIsExistIsNil())
	}
	if i.PlateIsExistNotNil {
		predicates = append(predicates, vehicledata.PlateIsExistNotNil())
	}
	if i.PlateColor != nil {
		predicates = append(predicates, vehicledata.PlateColorEQ(*i.PlateColor))
	}
	if i.PlateColorNEQ != nil {
		predicates = append(predicates, vehicledata.PlateColorNEQ(*i.PlateColorNEQ))
	}
	if len(i.PlateColorIn) > 0 {
		predicates = append(predicates, vehicledata.PlateColorIn(i.PlateColorIn...))
	}
	if len(i.PlateColorNotIn) > 0 {
		predicates = append(predicates, vehicledata.PlateColorNotIn(i.PlateColorNotIn...))
	}
	if i.PlateColorGT != nil {
		predicates = append(predicates, vehicledata.PlateColorGT(*i.PlateColorGT))
	}
	if i.PlateColorGTE != nil {
		predicates = append(predicates, vehicledata.PlateColorGTE(*i.PlateColorGTE))
	}
	if i.PlateColorLT != nil {
		predicates = append(predicates, vehicledata.PlateColorLT(*i.PlateColorLT))
	}
	if i.PlateColorLTE != nil {
		predicates = append(predicates, vehicledata.PlateColorLTE(*i.PlateColorLTE))
	}
	if i.PlateColorContains != nil {
		predicates = append(predicates, vehicledata.PlateColorContains(*i.PlateColorContains))
	}
	if i.PlateColorHasPrefix != nil {
		predicates = append(predicates, vehicledata.PlateColorHasPrefix(*i.PlateColorHasPrefix))
	}
	if i.PlateColorHasSuffix != nil {
		predicates = append(predicates, vehicledata.PlateColorHasSuffix(*i.PlateColorHasSuffix))
	}
	if i.PlateColorIsNil {
		predicates = append(predicates, vehicledata.PlateColorIsNil())
	}
	if i.PlateColorNotNil {
		predicates = append(predicates, vehicledata.PlateColorNotNil())
	}
	if i.PlateColorEqualFold != nil {
		predicates = append(predicates, vehicledata.PlateColorEqualFold(*i.PlateColorEqualFold))
	}
	if i.PlateColorContainsFold != nil {
		predicates = append(predicates, vehicledata.PlateColorContainsFold(*i.PlateColorContainsFold))
	}
	if i.PlateNumber != nil {
		predicates = append(predicates, vehicledata.PlateNumberEQ(*i.PlateNumber))
	}
	if i.PlateNumberNEQ != nil {
		predicates = append(predicates, vehicledata.PlateNumberNEQ(*i.PlateNumberNEQ))
	}
	if len(i.PlateNumberIn) > 0 {
		predicates = append(predicates, vehicledata.PlateNumberIn(i.PlateNumberIn...))
	}
	if len(i.PlateNumberNotIn) > 0 {
		predicates = append(predicates, vehicledata.PlateNumberNotIn(i.PlateNumberNotIn...))
	}
	if i.PlateNumberGT != nil {
		predicates = append(predicates, vehicledata.PlateNumberGT(*i.PlateNumberGT))
	}
	if i.PlateNumberGTE != nil {
		predicates = append(predicates, vehicledata.PlateNumberGTE(*i.PlateNumberGTE))
	}
	if i.PlateNumberLT != nil {
		predicates = append(predicates, vehicledata.PlateNumberLT(*i.PlateNumberLT))
	}
	if i.PlateNumberLTE != nil {
		predicates = append(predicates, vehicledata.PlateNumberLTE(*i.PlateNumberLTE))
	}
	if i.PlateNumberContains != nil {
		predicates = append(predicates, vehicledata.PlateNumberContains(*i.PlateNumberContains))
	}
	if i.PlateNumberHasPrefix != nil {
		predicates = append(predicates, vehicledata.PlateNumberHasPrefix(*i.PlateNumberHasPrefix))
	}
	if i.PlateNumberHasSuffix != nil {
		predicates = append(predicates, vehicledata.PlateNumberHasSuffix(*i.PlateNumberHasSuffix))
	}
	if i.PlateNumberIsNil {
		predicates = append(predicates, vehicledata.PlateNumberIsNil())
	}
	if i.PlateNumberNotNil {
		predicates = append(predicates, vehicledata.PlateNumberNotNil())
	}
	if i.PlateNumberEqualFold != nil {
		predicates = append(predicates, vehicledata.PlateNumberEqualFold(*i.PlateNumberEqualFold))
	}
	if i.PlateNumberContainsFold != nil {
		predicates = append(predicates, vehicledata.PlateNumberContainsFold(*i.PlateNumberContainsFold))
	}
	if i.PlateType != nil {
		predicates = append(predicates, vehicledata.PlateTypeEQ(*i.PlateType))
	}
	if i.PlateTypeNEQ != nil {
		predicates = append(predicates, vehicledata.PlateTypeNEQ(*i.PlateTypeNEQ))
	}
	if len(i.PlateTypeIn) > 0 {
		predicates = append(predicates, vehicledata.PlateTypeIn(i.PlateTypeIn...))
	}
	if len(i.PlateTypeNotIn) > 0 {
		predicates = append(predicates, vehicledata.PlateTypeNotIn(i.PlateTypeNotIn...))
	}
	if i.PlateTypeGT != nil {
		predicates = append(predicates, vehicledata.PlateTypeGT(*i.PlateTypeGT))
	}
	if i.PlateTypeGTE != nil {
		predicates = append(predicates, vehicledata.PlateTypeGTE(*i.PlateTypeGTE))
	}
	if i.PlateTypeLT != nil {
		predicates = append(predicates, vehicledata.PlateTypeLT(*i.PlateTypeLT))
	}
	if i.PlateTypeLTE != nil {
		predicates = append(predicates, vehicledata.PlateTypeLTE(*i.PlateTypeLTE))
	}
	if i.PlateTypeContains != nil {
		predicates = append(predicates, vehicledata.PlateTypeContains(*i.PlateTypeContains))
	}
	if i.PlateTypeHasPrefix != nil {
		predicates = append(predicates, vehicledata.PlateTypeHasPrefix(*i.PlateTypeHasPrefix))
	}
	if i.PlateTypeHasSuffix != nil {
		predicates = append(predicates, vehicledata.PlateTypeHasSuffix(*i.PlateTypeHasSuffix))
	}
	if i.PlateTypeIsNil {
		predicates = append(predicates, vehicledata.PlateTypeIsNil())
	}
	if i.PlateTypeNotNil {
		predicates = append(predicates, vehicledata.PlateTypeNotNil())
	}
	if i.PlateTypeEqualFold != nil {
		predicates = append(predicates, vehicledata.PlateTypeEqualFold(*i.PlateTypeEqualFold))
	}
	if i.PlateTypeContainsFold != nil {
		predicates = append(predicates, vehicledata.PlateTypeContainsFold(*i.PlateTypeContainsFold))
	}
	if i.PlateRegion != nil {
		predicates = append(predicates, vehicledata.PlateRegionEQ(*i.PlateRegion))
	}
	if i.PlateRegionNEQ != nil {
		predicates = append(predicates, vehicledata.PlateRegionNEQ(*i.PlateRegionNEQ))
	}
	if len(i.PlateRegionIn) > 0 {
		predicates = append(predicates, vehicledata.PlateRegionIn(i.PlateRegionIn...))
	}
	if len(i.PlateRegionNotIn) > 0 {
		predicates = append(predicates, vehicledata.PlateRegionNotIn(i.PlateRegionNotIn...))
	}
	if i.PlateRegionGT != nil {
		predicates = append(predicates, vehicledata.PlateRegionGT(*i.PlateRegionGT))
	}
	if i.PlateRegionGTE != nil {
		predicates = append(predicates, vehicledata.PlateRegionGTE(*i.PlateRegionGTE))
	}
	if i.PlateRegionLT != nil {
		predicates = append(predicates, vehicledata.PlateRegionLT(*i.PlateRegionLT))
	}
	if i.PlateRegionLTE != nil {
		predicates = append(predicates, vehicledata.PlateRegionLTE(*i.PlateRegionLTE))
	}
	if i.PlateRegionContains != nil {
		predicates = append(predicates, vehicledata.PlateRegionContains(*i.PlateRegionContains))
	}
	if i.PlateRegionHasPrefix != nil {
		predicates = append(predicates, vehicledata.PlateRegionHasPrefix(*i.PlateRegionHasPrefix))
	}
	if i.PlateRegionHasSuffix != nil {
		predicates = append(predicates, vehicledata.PlateRegionHasSuffix(*i.PlateRegionHasSuffix))
	}
	if i.PlateRegionIsNil {
		predicates = append(predicates, vehicledata.PlateRegionIsNil())
	}
	if i.PlateRegionNotNil {
		predicates = append(predicates, vehicledata.PlateRegionNotNil())
	}
	if i.PlateRegionEqualFold != nil {
		predicates = append(predicates, vehicledata.PlateRegionEqualFold(*i.PlateRegionEqualFold))
	}
	if i.PlateRegionContainsFold != nil {
		predicates = append(predicates, vehicledata.PlateRegionContainsFold(*i.PlateRegionContainsFold))
	}
	if i.PlateUploadNum != nil {
		predicates = append(predicates, vehicledata.PlateUploadNumEQ(*i.PlateUploadNum))
	}
	if i.PlateUploadNumNEQ != nil {
		predicates = append(predicates, vehicledata.PlateUploadNumNEQ(*i.PlateUploadNumNEQ))
	}
	if len(i.PlateUploadNumIn) > 0 {
		predicates = append(predicates, vehicledata.PlateUploadNumIn(i.PlateUploadNumIn...))
	}
	if len(i.PlateUploadNumNotIn) > 0 {
		predicates = append(predicates, vehicledata.PlateUploadNumNotIn(i.PlateUploadNumNotIn...))
	}
	if i.PlateUploadNumGT != nil {
		predicates = append(predicates, vehicledata.PlateUploadNumGT(*i.PlateUploadNumGT))
	}
	if i.PlateUploadNumGTE != nil {
		predicates = append(predicates, vehicledata.PlateUploadNumGTE(*i.PlateUploadNumGTE))
	}
	if i.PlateUploadNumLT != nil {
		predicates = append(predicates, vehicledata.PlateUploadNumLT(*i.PlateUploadNumLT))
	}
	if i.PlateUploadNumLTE != nil {
		predicates = append(predicates, vehicledata.PlateUploadNumLTE(*i.PlateUploadNumLTE))
	}
	if i.PlateUploadNumIsNil {
		predicates = append(predicates, vehicledata.PlateUploadNumIsNil())
	}
	if i.PlateUploadNumNotNil {
		predicates = append(predicates, vehicledata.PlateUploadNumNotNil())
	}
	if i.SnapAllowUser != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEQ(*i.SnapAllowUser))
	}
	if i.SnapAllowUserNEQ != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserNEQ(*i.SnapAllowUserNEQ))
	}
	if i.SnapAllowUserIsNil {
		predicates = append(predicates, vehicledata.SnapAllowUserIsNil())
	}
	if i.SnapAllowUserNotNil {
		predicates = append(predicates, vehicledata.SnapAllowUserNotNil())
	}
	if i.SnapAllowUserEndTime != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeEQ(*i.SnapAllowUserEndTime))
	}
	if i.SnapAllowUserEndTimeNEQ != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeNEQ(*i.SnapAllowUserEndTimeNEQ))
	}
	if len(i.SnapAllowUserEndTimeIn) > 0 {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeIn(i.SnapAllowUserEndTimeIn...))
	}
	if len(i.SnapAllowUserEndTimeNotIn) > 0 {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeNotIn(i.SnapAllowUserEndTimeNotIn...))
	}
	if i.SnapAllowUserEndTimeGT != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeGT(*i.SnapAllowUserEndTimeGT))
	}
	if i.SnapAllowUserEndTimeGTE != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeGTE(*i.SnapAllowUserEndTimeGTE))
	}
	if i.SnapAllowUserEndTimeLT != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeLT(*i.SnapAllowUserEndTimeLT))
	}
	if i.SnapAllowUserEndTimeLTE != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeLTE(*i.SnapAllowUserEndTimeLTE))
	}
	if i.SnapAllowUserEndTimeContains != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeContains(*i.SnapAllowUserEndTimeContains))
	}
	if i.SnapAllowUserEndTimeHasPrefix != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeHasPrefix(*i.SnapAllowUserEndTimeHasPrefix))
	}
	if i.SnapAllowUserEndTimeHasSuffix != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeHasSuffix(*i.SnapAllowUserEndTimeHasSuffix))
	}
	if i.SnapAllowUserEndTimeIsNil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeIsNil())
	}
	if i.SnapAllowUserEndTimeNotNil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeNotNil())
	}
	if i.SnapAllowUserEndTimeEqualFold != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeEqualFold(*i.SnapAllowUserEndTimeEqualFold))
	}
	if i.SnapAllowUserEndTimeContainsFold != nil {
		predicates = append(predicates, vehicledata.SnapAllowUserEndTimeContainsFold(*i.SnapAllowUserEndTimeContainsFold))
	}
	if i.SnapDefenceCode != nil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeEQ(*i.SnapDefenceCode))
	}
	if i.SnapDefenceCodeNEQ != nil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeNEQ(*i.SnapDefenceCodeNEQ))
	}
	if len(i.SnapDefenceCodeIn) > 0 {
		predicates = append(predicates, vehicledata.SnapDefenceCodeIn(i.SnapDefenceCodeIn...))
	}
	if len(i.SnapDefenceCodeNotIn) > 0 {
		predicates = append(predicates, vehicledata.SnapDefenceCodeNotIn(i.SnapDefenceCodeNotIn...))
	}
	if i.SnapDefenceCodeGT != nil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeGT(*i.SnapDefenceCodeGT))
	}
	if i.SnapDefenceCodeGTE != nil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeGTE(*i.SnapDefenceCodeGTE))
	}
	if i.SnapDefenceCodeLT != nil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeLT(*i.SnapDefenceCodeLT))
	}
	if i.SnapDefenceCodeLTE != nil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeLTE(*i.SnapDefenceCodeLTE))
	}
	if i.SnapDefenceCodeContains != nil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeContains(*i.SnapDefenceCodeContains))
	}
	if i.SnapDefenceCodeHasPrefix != nil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeHasPrefix(*i.SnapDefenceCodeHasPrefix))
	}
	if i.SnapDefenceCodeHasSuffix != nil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeHasSuffix(*i.SnapDefenceCodeHasSuffix))
	}
	if i.SnapDefenceCodeIsNil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeIsNil())
	}
	if i.SnapDefenceCodeNotNil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeNotNil())
	}
	if i.SnapDefenceCodeEqualFold != nil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeEqualFold(*i.SnapDefenceCodeEqualFold))
	}
	if i.SnapDefenceCodeContainsFold != nil {
		predicates = append(predicates, vehicledata.SnapDefenceCodeContainsFold(*i.SnapDefenceCodeContainsFold))
	}
	if i.SnapDeviceID != nil {
		predicates = append(predicates, vehicledata.SnapDeviceIDEQ(*i.SnapDeviceID))
	}
	if i.SnapDeviceIDNEQ != nil {
		predicates = append(predicates, vehicledata.SnapDeviceIDNEQ(*i.SnapDeviceIDNEQ))
	}
	if len(i.SnapDeviceIDIn) > 0 {
		predicates = append(predicates, vehicledata.SnapDeviceIDIn(i.SnapDeviceIDIn...))
	}
	if len(i.SnapDeviceIDNotIn) > 0 {
		predicates = append(predicates, vehicledata.SnapDeviceIDNotIn(i.SnapDeviceIDNotIn...))
	}
	if i.SnapDeviceIDGT != nil {
		predicates = append(predicates, vehicledata.SnapDeviceIDGT(*i.SnapDeviceIDGT))
	}
	if i.SnapDeviceIDGTE != nil {
		predicates = append(predicates, vehicledata.SnapDeviceIDGTE(*i.SnapDeviceIDGTE))
	}
	if i.SnapDeviceIDLT != nil {
		predicates = append(predicates, vehicledata.SnapDeviceIDLT(*i.SnapDeviceIDLT))
	}
	if i.SnapDeviceIDLTE != nil {
		predicates = append(predicates, vehicledata.SnapDeviceIDLTE(*i.SnapDeviceIDLTE))
	}
	if i.SnapDeviceIDContains != nil {
		predicates = append(predicates, vehicledata.SnapDeviceIDContains(*i.SnapDeviceIDContains))
	}
	if i.SnapDeviceIDHasPrefix != nil {
		predicates = append(predicates, vehicledata.SnapDeviceIDHasPrefix(*i.SnapDeviceIDHasPrefix))
	}
	if i.SnapDeviceIDHasSuffix != nil {
		predicates = append(predicates, vehicledata.SnapDeviceIDHasSuffix(*i.SnapDeviceIDHasSuffix))
	}
	if i.SnapDeviceIDIsNil {
		predicates = append(predicates, vehicledata.SnapDeviceIDIsNil())
	}
	if i.SnapDeviceIDNotNil {
		predicates = append(predicates, vehicledata.SnapDeviceIDNotNil())
	}
	if i.SnapDeviceIDEqualFold != nil {
		predicates = append(predicates, vehicledata.SnapDeviceIDEqualFold(*i.SnapDeviceIDEqualFold))
	}
	if i.SnapDeviceIDContainsFold != nil {
		predicates = append(predicates, vehicledata.SnapDeviceIDContainsFold(*i.SnapDeviceIDContainsFold))
	}
	if i.SnapInCarPeopleNum != nil {
		predicates = append(predicates, vehicledata.SnapInCarPeopleNumEQ(*i.SnapInCarPeopleNum))
	}
	if i.SnapInCarPeopleNumNEQ != nil {
		predicates = append(predicates, vehicledata.SnapInCarPeopleNumNEQ(*i.SnapInCarPeopleNumNEQ))
	}
	if len(i.SnapInCarPeopleNumIn) > 0 {
		predicates = append(predicates, vehicledata.SnapInCarPeopleNumIn(i.SnapInCarPeopleNumIn...))
	}
	if len(i.SnapInCarPeopleNumNotIn) > 0 {
		predicates = append(predicates, vehicledata.SnapInCarPeopleNumNotIn(i.SnapInCarPeopleNumNotIn...))
	}
	if i.SnapInCarPeopleNumGT != nil {
		predicates = append(predicates, vehicledata.SnapInCarPeopleNumGT(*i.SnapInCarPeopleNumGT))
	}
	if i.SnapInCarPeopleNumGTE != nil {
		predicates = append(predicates, vehicledata.SnapInCarPeopleNumGTE(*i.SnapInCarPeopleNumGTE))
	}
	if i.SnapInCarPeopleNumLT != nil {
		predicates = append(predicates, vehicledata.SnapInCarPeopleNumLT(*i.SnapInCarPeopleNumLT))
	}
	if i.SnapInCarPeopleNumLTE != nil {
		predicates = append(predicates, vehicledata.SnapInCarPeopleNumLTE(*i.SnapInCarPeopleNumLTE))
	}
	if i.SnapInCarPeopleNumIsNil {
		predicates = append(predicates, vehicledata.SnapInCarPeopleNumIsNil())
	}
	if i.SnapInCarPeopleNumNotNil {
		predicates = append(predicates, vehicledata.SnapInCarPeopleNumNotNil())
	}
	if i.SnapLanNo != nil {
		predicates = append(predicates, vehicledata.SnapLanNoEQ(*i.SnapLanNo))
	}
	if i.SnapLanNoNEQ != nil {
		predicates = append(predicates, vehicledata.SnapLanNoNEQ(*i.SnapLanNoNEQ))
	}
	if len(i.SnapLanNoIn) > 0 {
		predicates = append(predicates, vehicledata.SnapLanNoIn(i.SnapLanNoIn...))
	}
	if len(i.SnapLanNoNotIn) > 0 {
		predicates = append(predicates, vehicledata.SnapLanNoNotIn(i.SnapLanNoNotIn...))
	}
	if i.SnapLanNoGT != nil {
		predicates = append(predicates, vehicledata.SnapLanNoGT(*i.SnapLanNoGT))
	}
	if i.SnapLanNoGTE != nil {
		predicates = append(predicates, vehicledata.SnapLanNoGTE(*i.SnapLanNoGTE))
	}
	if i.SnapLanNoLT != nil {
		predicates = append(predicates, vehicledata.SnapLanNoLT(*i.SnapLanNoLT))
	}
	if i.SnapLanNoLTE != nil {
		predicates = append(predicates, vehicledata.SnapLanNoLTE(*i.SnapLanNoLTE))
	}
	if i.SnapLanNoIsNil {
		predicates = append(predicates, vehicledata.SnapLanNoIsNil())
	}
	if i.SnapLanNoNotNil {
		predicates = append(predicates, vehicledata.SnapLanNoNotNil())
	}
	if i.SnapOpenStrobe != nil {
		predicates = append(predicates, vehicledata.SnapOpenStrobeEQ(*i.SnapOpenStrobe))
	}
	if i.SnapOpenStrobeNEQ != nil {
		predicates = append(predicates, vehicledata.SnapOpenStrobeNEQ(*i.SnapOpenStrobeNEQ))
	}
	if i.SnapOpenStrobeIsNil {
		predicates = append(predicates, vehicledata.SnapOpenStrobeIsNil())
	}
	if i.SnapOpenStrobeNotNil {
		predicates = append(predicates, vehicledata.SnapOpenStrobeNotNil())
	}
	if i.VehicleSeries != nil {
		predicates = append(predicates, vehicledata.VehicleSeriesEQ(*i.VehicleSeries))
	}
	if i.VehicleSeriesNEQ != nil {
		predicates = append(predicates, vehicledata.VehicleSeriesNEQ(*i.VehicleSeriesNEQ))
	}
	if len(i.VehicleSeriesIn) > 0 {
		predicates = append(predicates, vehicledata.VehicleSeriesIn(i.VehicleSeriesIn...))
	}
	if len(i.VehicleSeriesNotIn) > 0 {
		predicates = append(predicates, vehicledata.VehicleSeriesNotIn(i.VehicleSeriesNotIn...))
	}
	if i.VehicleSeriesGT != nil {
		predicates = append(predicates, vehicledata.VehicleSeriesGT(*i.VehicleSeriesGT))
	}
	if i.VehicleSeriesGTE != nil {
		predicates = append(predicates, vehicledata.VehicleSeriesGTE(*i.VehicleSeriesGTE))
	}
	if i.VehicleSeriesLT != nil {
		predicates = append(predicates, vehicledata.VehicleSeriesLT(*i.VehicleSeriesLT))
	}
	if i.VehicleSeriesLTE != nil {
		predicates = append(predicates, vehicledata.VehicleSeriesLTE(*i.VehicleSeriesLTE))
	}
	if i.VehicleSeriesContains != nil {
		predicates = append(predicates, vehicledata.VehicleSeriesContains(*i.VehicleSeriesContains))
	}
	if i.VehicleSeriesHasPrefix != nil {
		predicates = append(predicates, vehicledata.VehicleSeriesHasPrefix(*i.VehicleSeriesHasPrefix))
	}
	if i.VehicleSeriesHasSuffix != nil {
		predicates = append(predicates, vehicledata.VehicleSeriesHasSuffix(*i.VehicleSeriesHasSuffix))
	}
	if i.VehicleSeriesIsNil {
		predicates = append(predicates, vehicledata.VehicleSeriesIsNil())
	}
	if i.VehicleSeriesNotNil {
		predicates = append(predicates, vehicledata.VehicleSeriesNotNil())
	}
	if i.VehicleSeriesEqualFold != nil {
		predicates = append(predicates, vehicledata.VehicleSeriesEqualFold(*i.VehicleSeriesEqualFold))
	}
	if i.VehicleSeriesContainsFold != nil {
		predicates = append(predicates, vehicledata.VehicleSeriesContainsFold(*i.VehicleSeriesContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyVehicleDataWhereInput
	case 1:
		return predicates[0], nil
	default:
		return vehicledata.And(predicates...), nil
	}
}
