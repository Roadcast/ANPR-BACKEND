// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"go-ent-project/internal/ent/camera"
	"go-ent-project/internal/ent/car"
	"go-ent-project/internal/ent/event"
	"go-ent-project/internal/ent/permission"
	"go-ent-project/internal/ent/policestation"
	"go-ent-project/internal/ent/predicate"
	"go-ent-project/internal/ent/role"
	"go-ent-project/internal/ent/user"
	"time"

	"github.com/google/uuid"
)

// CameraWhereInput represents a where input for filtering Camera queries.
type CameraWhereInput struct {
	Predicates []predicate.Camera  `json:"-"`
	Not        *CameraWhereInput   `json:"not,omitempty"`
	Or         []*CameraWhereInput `json:"or,omitempty"`
	And        []*CameraWhereInput `json:"and,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "imei" field predicates.
	Imei             *string  `json:"imei,omitempty"`
	ImeiNEQ          *string  `json:"imeiNEQ,omitempty"`
	ImeiIn           []string `json:"imeiIn,omitempty"`
	ImeiNotIn        []string `json:"imeiNotIn,omitempty"`
	ImeiGT           *string  `json:"imeiGT,omitempty"`
	ImeiGTE          *string  `json:"imeiGTE,omitempty"`
	ImeiLT           *string  `json:"imeiLT,omitempty"`
	ImeiLTE          *string  `json:"imeiLTE,omitempty"`
	ImeiContains     *string  `json:"imeiContains,omitempty"`
	ImeiHasPrefix    *string  `json:"imeiHasPrefix,omitempty"`
	ImeiHasSuffix    *string  `json:"imeiHasSuffix,omitempty"`
	ImeiEqualFold    *string  `json:"imeiEqualFold,omitempty"`
	ImeiContainsFold *string  `json:"imeiContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "is_working" field predicates.
	IsWorking    *bool `json:"isWorking,omitempty"`
	IsWorkingNEQ *bool `json:"isWorkingNEQ,omitempty"`

	// "district" field predicates.
	District             *string  `json:"district,omitempty"`
	DistrictNEQ          *string  `json:"districtNEQ,omitempty"`
	DistrictIn           []string `json:"districtIn,omitempty"`
	DistrictNotIn        []string `json:"districtNotIn,omitempty"`
	DistrictGT           *string  `json:"districtGT,omitempty"`
	DistrictGTE          *string  `json:"districtGTE,omitempty"`
	DistrictLT           *string  `json:"districtLT,omitempty"`
	DistrictLTE          *string  `json:"districtLTE,omitempty"`
	DistrictContains     *string  `json:"districtContains,omitempty"`
	DistrictHasPrefix    *string  `json:"districtHasPrefix,omitempty"`
	DistrictHasSuffix    *string  `json:"districtHasSuffix,omitempty"`
	DistrictEqualFold    *string  `json:"districtEqualFold,omitempty"`
	DistrictContainsFold *string  `json:"districtContainsFold,omitempty"`

	// "last_ping" field predicates.
	LastPing      *time.Time  `json:"lastPing,omitempty"`
	LastPingNEQ   *time.Time  `json:"lastPingNEQ,omitempty"`
	LastPingIn    []time.Time `json:"lastPingIn,omitempty"`
	LastPingNotIn []time.Time `json:"lastPingNotIn,omitempty"`
	LastPingGT    *time.Time  `json:"lastPingGT,omitempty"`
	LastPingGTE   *time.Time  `json:"lastPingGTE,omitempty"`
	LastPingLT    *time.Time  `json:"lastPingLT,omitempty"`
	LastPingLTE   *time.Time  `json:"lastPingLTE,omitempty"`

	// "police_station" edge predicates.
	HasPoliceStation     *bool                      `json:"hasPoliceStation,omitempty"`
	HasPoliceStationWith []*PoliceStationWhereInput `json:"hasPoliceStationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CameraWhereInput) AddPredicates(predicates ...predicate.Camera) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CameraWhereInput filter on the CameraQuery builder.
func (i *CameraWhereInput) Filter(q *CameraQuery) (*CameraQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCameraWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCameraWhereInput is returned in case the CameraWhereInput is empty.
var ErrEmptyCameraWhereInput = errors.New("ent: empty predicate CameraWhereInput")

// P returns a predicate for filtering cameras.
// An error is returned if the input is empty or invalid.
func (i *CameraWhereInput) P() (predicate.Camera, error) {
	var predicates []predicate.Camera
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, camera.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Camera, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, camera.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Camera, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, camera.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.CreatedAt != nil {
		predicates = append(predicates, camera.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, camera.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, camera.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, camera.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, camera.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, camera.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, camera.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, camera.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, camera.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, camera.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, camera.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, camera.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, camera.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, camera.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, camera.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, camera.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, camera.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, camera.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, camera.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, camera.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, camera.NameContainsFold(*i.NameContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, camera.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, camera.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, camera.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, camera.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, camera.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, camera.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, camera.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, camera.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, camera.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, camera.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, camera.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, camera.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, camera.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Imei != nil {
		predicates = append(predicates, camera.ImeiEQ(*i.Imei))
	}
	if i.ImeiNEQ != nil {
		predicates = append(predicates, camera.ImeiNEQ(*i.ImeiNEQ))
	}
	if len(i.ImeiIn) > 0 {
		predicates = append(predicates, camera.ImeiIn(i.ImeiIn...))
	}
	if len(i.ImeiNotIn) > 0 {
		predicates = append(predicates, camera.ImeiNotIn(i.ImeiNotIn...))
	}
	if i.ImeiGT != nil {
		predicates = append(predicates, camera.ImeiGT(*i.ImeiGT))
	}
	if i.ImeiGTE != nil {
		predicates = append(predicates, camera.ImeiGTE(*i.ImeiGTE))
	}
	if i.ImeiLT != nil {
		predicates = append(predicates, camera.ImeiLT(*i.ImeiLT))
	}
	if i.ImeiLTE != nil {
		predicates = append(predicates, camera.ImeiLTE(*i.ImeiLTE))
	}
	if i.ImeiContains != nil {
		predicates = append(predicates, camera.ImeiContains(*i.ImeiContains))
	}
	if i.ImeiHasPrefix != nil {
		predicates = append(predicates, camera.ImeiHasPrefix(*i.ImeiHasPrefix))
	}
	if i.ImeiHasSuffix != nil {
		predicates = append(predicates, camera.ImeiHasSuffix(*i.ImeiHasSuffix))
	}
	if i.ImeiEqualFold != nil {
		predicates = append(predicates, camera.ImeiEqualFold(*i.ImeiEqualFold))
	}
	if i.ImeiContainsFold != nil {
		predicates = append(predicates, camera.ImeiContainsFold(*i.ImeiContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, camera.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, camera.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.Address != nil {
		predicates = append(predicates, camera.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, camera.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, camera.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, camera.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, camera.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, camera.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, camera.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, camera.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, camera.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, camera.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, camera.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, camera.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, camera.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, camera.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, camera.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.IsWorking != nil {
		predicates = append(predicates, camera.IsWorkingEQ(*i.IsWorking))
	}
	if i.IsWorkingNEQ != nil {
		predicates = append(predicates, camera.IsWorkingNEQ(*i.IsWorkingNEQ))
	}
	if i.District != nil {
		predicates = append(predicates, camera.DistrictEQ(*i.District))
	}
	if i.DistrictNEQ != nil {
		predicates = append(predicates, camera.DistrictNEQ(*i.DistrictNEQ))
	}
	if len(i.DistrictIn) > 0 {
		predicates = append(predicates, camera.DistrictIn(i.DistrictIn...))
	}
	if len(i.DistrictNotIn) > 0 {
		predicates = append(predicates, camera.DistrictNotIn(i.DistrictNotIn...))
	}
	if i.DistrictGT != nil {
		predicates = append(predicates, camera.DistrictGT(*i.DistrictGT))
	}
	if i.DistrictGTE != nil {
		predicates = append(predicates, camera.DistrictGTE(*i.DistrictGTE))
	}
	if i.DistrictLT != nil {
		predicates = append(predicates, camera.DistrictLT(*i.DistrictLT))
	}
	if i.DistrictLTE != nil {
		predicates = append(predicates, camera.DistrictLTE(*i.DistrictLTE))
	}
	if i.DistrictContains != nil {
		predicates = append(predicates, camera.DistrictContains(*i.DistrictContains))
	}
	if i.DistrictHasPrefix != nil {
		predicates = append(predicates, camera.DistrictHasPrefix(*i.DistrictHasPrefix))
	}
	if i.DistrictHasSuffix != nil {
		predicates = append(predicates, camera.DistrictHasSuffix(*i.DistrictHasSuffix))
	}
	if i.DistrictEqualFold != nil {
		predicates = append(predicates, camera.DistrictEqualFold(*i.DistrictEqualFold))
	}
	if i.DistrictContainsFold != nil {
		predicates = append(predicates, camera.DistrictContainsFold(*i.DistrictContainsFold))
	}
	if i.LastPing != nil {
		predicates = append(predicates, camera.LastPingEQ(*i.LastPing))
	}
	if i.LastPingNEQ != nil {
		predicates = append(predicates, camera.LastPingNEQ(*i.LastPingNEQ))
	}
	if len(i.LastPingIn) > 0 {
		predicates = append(predicates, camera.LastPingIn(i.LastPingIn...))
	}
	if len(i.LastPingNotIn) > 0 {
		predicates = append(predicates, camera.LastPingNotIn(i.LastPingNotIn...))
	}
	if i.LastPingGT != nil {
		predicates = append(predicates, camera.LastPingGT(*i.LastPingGT))
	}
	if i.LastPingGTE != nil {
		predicates = append(predicates, camera.LastPingGTE(*i.LastPingGTE))
	}
	if i.LastPingLT != nil {
		predicates = append(predicates, camera.LastPingLT(*i.LastPingLT))
	}
	if i.LastPingLTE != nil {
		predicates = append(predicates, camera.LastPingLTE(*i.LastPingLTE))
	}

	if i.HasPoliceStation != nil {
		p := camera.HasPoliceStation()
		if !*i.HasPoliceStation {
			p = camera.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPoliceStationWith) > 0 {
		with := make([]predicate.PoliceStation, 0, len(i.HasPoliceStationWith))
		for _, w := range i.HasPoliceStationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPoliceStationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, camera.HasPoliceStationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCameraWhereInput
	case 1:
		return predicates[0], nil
	default:
		return camera.And(predicates...), nil
	}
}

// CarWhereInput represents a where input for filtering Car queries.
type CarWhereInput struct {
	Predicates []predicate.Car  `json:"-"`
	Not        *CarWhereInput   `json:"not,omitempty"`
	Or         []*CarWhereInput `json:"or,omitempty"`
	And        []*CarWhereInput `json:"and,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "make" field predicates.
	Make             *string  `json:"make,omitempty"`
	MakeNEQ          *string  `json:"makeNEQ,omitempty"`
	MakeIn           []string `json:"makeIn,omitempty"`
	MakeNotIn        []string `json:"makeNotIn,omitempty"`
	MakeGT           *string  `json:"makeGT,omitempty"`
	MakeGTE          *string  `json:"makeGTE,omitempty"`
	MakeLT           *string  `json:"makeLT,omitempty"`
	MakeLTE          *string  `json:"makeLTE,omitempty"`
	MakeContains     *string  `json:"makeContains,omitempty"`
	MakeHasPrefix    *string  `json:"makeHasPrefix,omitempty"`
	MakeHasSuffix    *string  `json:"makeHasSuffix,omitempty"`
	MakeIsNil        bool     `json:"makeIsNil,omitempty"`
	MakeNotNil       bool     `json:"makeNotNil,omitempty"`
	MakeEqualFold    *string  `json:"makeEqualFold,omitempty"`
	MakeContainsFold *string  `json:"makeContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelIsNil        bool     `json:"modelIsNil,omitempty"`
	ModelNotNil       bool     `json:"modelNotNil,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "year" field predicates.
	Year       *int  `json:"year,omitempty"`
	YearNEQ    *int  `json:"yearNEQ,omitempty"`
	YearIn     []int `json:"yearIn,omitempty"`
	YearNotIn  []int `json:"yearNotIn,omitempty"`
	YearGT     *int  `json:"yearGT,omitempty"`
	YearGTE    *int  `json:"yearGTE,omitempty"`
	YearLT     *int  `json:"yearLT,omitempty"`
	YearLTE    *int  `json:"yearLTE,omitempty"`
	YearIsNil  bool  `json:"yearIsNil,omitempty"`
	YearNotNil bool  `json:"yearNotNil,omitempty"`

	// "registration" field predicates.
	Registration             *string  `json:"registration,omitempty"`
	RegistrationNEQ          *string  `json:"registrationNEQ,omitempty"`
	RegistrationIn           []string `json:"registrationIn,omitempty"`
	RegistrationNotIn        []string `json:"registrationNotIn,omitempty"`
	RegistrationGT           *string  `json:"registrationGT,omitempty"`
	RegistrationGTE          *string  `json:"registrationGTE,omitempty"`
	RegistrationLT           *string  `json:"registrationLT,omitempty"`
	RegistrationLTE          *string  `json:"registrationLTE,omitempty"`
	RegistrationContains     *string  `json:"registrationContains,omitempty"`
	RegistrationHasPrefix    *string  `json:"registrationHasPrefix,omitempty"`
	RegistrationHasSuffix    *string  `json:"registrationHasSuffix,omitempty"`
	RegistrationEqualFold    *string  `json:"registrationEqualFold,omitempty"`
	RegistrationContainsFold *string  `json:"registrationContainsFold,omitempty"`

	// "color" field predicates.
	Color             *string  `json:"color,omitempty"`
	ColorNEQ          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGT           *string  `json:"colorGT,omitempty"`
	ColorGTE          *string  `json:"colorGTE,omitempty"`
	ColorLT           *string  `json:"colorLT,omitempty"`
	ColorLTE          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorIsNil        bool     `json:"colorIsNil,omitempty"`
	ColorNotNil       bool     `json:"colorNotNil,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`

	// "stolen_date" field predicates.
	StolenDate       *time.Time  `json:"stolenDate,omitempty"`
	StolenDateNEQ    *time.Time  `json:"stolenDateNEQ,omitempty"`
	StolenDateIn     []time.Time `json:"stolenDateIn,omitempty"`
	StolenDateNotIn  []time.Time `json:"stolenDateNotIn,omitempty"`
	StolenDateGT     *time.Time  `json:"stolenDateGT,omitempty"`
	StolenDateGTE    *time.Time  `json:"stolenDateGTE,omitempty"`
	StolenDateLT     *time.Time  `json:"stolenDateLT,omitempty"`
	StolenDateLTE    *time.Time  `json:"stolenDateLTE,omitempty"`
	StolenDateIsNil  bool        `json:"stolenDateIsNil,omitempty"`
	StolenDateNotNil bool        `json:"stolenDateNotNil,omitempty"`

	// "fir_number" field predicates.
	FirNumber             *string  `json:"firNumber,omitempty"`
	FirNumberNEQ          *string  `json:"firNumberNEQ,omitempty"`
	FirNumberIn           []string `json:"firNumberIn,omitempty"`
	FirNumberNotIn        []string `json:"firNumberNotIn,omitempty"`
	FirNumberGT           *string  `json:"firNumberGT,omitempty"`
	FirNumberGTE          *string  `json:"firNumberGTE,omitempty"`
	FirNumberLT           *string  `json:"firNumberLT,omitempty"`
	FirNumberLTE          *string  `json:"firNumberLTE,omitempty"`
	FirNumberContains     *string  `json:"firNumberContains,omitempty"`
	FirNumberHasPrefix    *string  `json:"firNumberHasPrefix,omitempty"`
	FirNumberHasSuffix    *string  `json:"firNumberHasSuffix,omitempty"`
	FirNumberIsNil        bool     `json:"firNumberIsNil,omitempty"`
	FirNumberNotNil       bool     `json:"firNumberNotNil,omitempty"`
	FirNumberEqualFold    *string  `json:"firNumberEqualFold,omitempty"`
	FirNumberContainsFold *string  `json:"firNumberContainsFold,omitempty"`

	// "police_station" edge predicates.
	HasPoliceStation     *bool                      `json:"hasPoliceStation,omitempty"`
	HasPoliceStationWith []*PoliceStationWhereInput `json:"hasPoliceStationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarWhereInput) AddPredicates(predicates ...predicate.Car) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarWhereInput filter on the CarQuery builder.
func (i *CarWhereInput) Filter(q *CarQuery) (*CarQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarWhereInput is returned in case the CarWhereInput is empty.
var ErrEmptyCarWhereInput = errors.New("ent: empty predicate CarWhereInput")

// P returns a predicate for filtering cars.
// An error is returned if the input is empty or invalid.
func (i *CarWhereInput) P() (predicate.Car, error) {
	var predicates []predicate.Car
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, car.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Car, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, car.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Car, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, car.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.CreatedAt != nil {
		predicates = append(predicates, car.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, car.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, car.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, car.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, car.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, car.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, car.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, car.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Make != nil {
		predicates = append(predicates, car.MakeEQ(*i.Make))
	}
	if i.MakeNEQ != nil {
		predicates = append(predicates, car.MakeNEQ(*i.MakeNEQ))
	}
	if len(i.MakeIn) > 0 {
		predicates = append(predicates, car.MakeIn(i.MakeIn...))
	}
	if len(i.MakeNotIn) > 0 {
		predicates = append(predicates, car.MakeNotIn(i.MakeNotIn...))
	}
	if i.MakeGT != nil {
		predicates = append(predicates, car.MakeGT(*i.MakeGT))
	}
	if i.MakeGTE != nil {
		predicates = append(predicates, car.MakeGTE(*i.MakeGTE))
	}
	if i.MakeLT != nil {
		predicates = append(predicates, car.MakeLT(*i.MakeLT))
	}
	if i.MakeLTE != nil {
		predicates = append(predicates, car.MakeLTE(*i.MakeLTE))
	}
	if i.MakeContains != nil {
		predicates = append(predicates, car.MakeContains(*i.MakeContains))
	}
	if i.MakeHasPrefix != nil {
		predicates = append(predicates, car.MakeHasPrefix(*i.MakeHasPrefix))
	}
	if i.MakeHasSuffix != nil {
		predicates = append(predicates, car.MakeHasSuffix(*i.MakeHasSuffix))
	}
	if i.MakeIsNil {
		predicates = append(predicates, car.MakeIsNil())
	}
	if i.MakeNotNil {
		predicates = append(predicates, car.MakeNotNil())
	}
	if i.MakeEqualFold != nil {
		predicates = append(predicates, car.MakeEqualFold(*i.MakeEqualFold))
	}
	if i.MakeContainsFold != nil {
		predicates = append(predicates, car.MakeContainsFold(*i.MakeContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, car.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, car.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, car.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, car.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, car.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, car.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, car.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, car.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, car.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, car.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, car.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelIsNil {
		predicates = append(predicates, car.ModelIsNil())
	}
	if i.ModelNotNil {
		predicates = append(predicates, car.ModelNotNil())
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, car.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, car.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Year != nil {
		predicates = append(predicates, car.YearEQ(*i.Year))
	}
	if i.YearNEQ != nil {
		predicates = append(predicates, car.YearNEQ(*i.YearNEQ))
	}
	if len(i.YearIn) > 0 {
		predicates = append(predicates, car.YearIn(i.YearIn...))
	}
	if len(i.YearNotIn) > 0 {
		predicates = append(predicates, car.YearNotIn(i.YearNotIn...))
	}
	if i.YearGT != nil {
		predicates = append(predicates, car.YearGT(*i.YearGT))
	}
	if i.YearGTE != nil {
		predicates = append(predicates, car.YearGTE(*i.YearGTE))
	}
	if i.YearLT != nil {
		predicates = append(predicates, car.YearLT(*i.YearLT))
	}
	if i.YearLTE != nil {
		predicates = append(predicates, car.YearLTE(*i.YearLTE))
	}
	if i.YearIsNil {
		predicates = append(predicates, car.YearIsNil())
	}
	if i.YearNotNil {
		predicates = append(predicates, car.YearNotNil())
	}
	if i.Registration != nil {
		predicates = append(predicates, car.RegistrationEQ(*i.Registration))
	}
	if i.RegistrationNEQ != nil {
		predicates = append(predicates, car.RegistrationNEQ(*i.RegistrationNEQ))
	}
	if len(i.RegistrationIn) > 0 {
		predicates = append(predicates, car.RegistrationIn(i.RegistrationIn...))
	}
	if len(i.RegistrationNotIn) > 0 {
		predicates = append(predicates, car.RegistrationNotIn(i.RegistrationNotIn...))
	}
	if i.RegistrationGT != nil {
		predicates = append(predicates, car.RegistrationGT(*i.RegistrationGT))
	}
	if i.RegistrationGTE != nil {
		predicates = append(predicates, car.RegistrationGTE(*i.RegistrationGTE))
	}
	if i.RegistrationLT != nil {
		predicates = append(predicates, car.RegistrationLT(*i.RegistrationLT))
	}
	if i.RegistrationLTE != nil {
		predicates = append(predicates, car.RegistrationLTE(*i.RegistrationLTE))
	}
	if i.RegistrationContains != nil {
		predicates = append(predicates, car.RegistrationContains(*i.RegistrationContains))
	}
	if i.RegistrationHasPrefix != nil {
		predicates = append(predicates, car.RegistrationHasPrefix(*i.RegistrationHasPrefix))
	}
	if i.RegistrationHasSuffix != nil {
		predicates = append(predicates, car.RegistrationHasSuffix(*i.RegistrationHasSuffix))
	}
	if i.RegistrationEqualFold != nil {
		predicates = append(predicates, car.RegistrationEqualFold(*i.RegistrationEqualFold))
	}
	if i.RegistrationContainsFold != nil {
		predicates = append(predicates, car.RegistrationContainsFold(*i.RegistrationContainsFold))
	}
	if i.Color != nil {
		predicates = append(predicates, car.ColorEQ(*i.Color))
	}
	if i.ColorNEQ != nil {
		predicates = append(predicates, car.ColorNEQ(*i.ColorNEQ))
	}
	if len(i.ColorIn) > 0 {
		predicates = append(predicates, car.ColorIn(i.ColorIn...))
	}
	if len(i.ColorNotIn) > 0 {
		predicates = append(predicates, car.ColorNotIn(i.ColorNotIn...))
	}
	if i.ColorGT != nil {
		predicates = append(predicates, car.ColorGT(*i.ColorGT))
	}
	if i.ColorGTE != nil {
		predicates = append(predicates, car.ColorGTE(*i.ColorGTE))
	}
	if i.ColorLT != nil {
		predicates = append(predicates, car.ColorLT(*i.ColorLT))
	}
	if i.ColorLTE != nil {
		predicates = append(predicates, car.ColorLTE(*i.ColorLTE))
	}
	if i.ColorContains != nil {
		predicates = append(predicates, car.ColorContains(*i.ColorContains))
	}
	if i.ColorHasPrefix != nil {
		predicates = append(predicates, car.ColorHasPrefix(*i.ColorHasPrefix))
	}
	if i.ColorHasSuffix != nil {
		predicates = append(predicates, car.ColorHasSuffix(*i.ColorHasSuffix))
	}
	if i.ColorIsNil {
		predicates = append(predicates, car.ColorIsNil())
	}
	if i.ColorNotNil {
		predicates = append(predicates, car.ColorNotNil())
	}
	if i.ColorEqualFold != nil {
		predicates = append(predicates, car.ColorEqualFold(*i.ColorEqualFold))
	}
	if i.ColorContainsFold != nil {
		predicates = append(predicates, car.ColorContainsFold(*i.ColorContainsFold))
	}
	if i.StolenDate != nil {
		predicates = append(predicates, car.StolenDateEQ(*i.StolenDate))
	}
	if i.StolenDateNEQ != nil {
		predicates = append(predicates, car.StolenDateNEQ(*i.StolenDateNEQ))
	}
	if len(i.StolenDateIn) > 0 {
		predicates = append(predicates, car.StolenDateIn(i.StolenDateIn...))
	}
	if len(i.StolenDateNotIn) > 0 {
		predicates = append(predicates, car.StolenDateNotIn(i.StolenDateNotIn...))
	}
	if i.StolenDateGT != nil {
		predicates = append(predicates, car.StolenDateGT(*i.StolenDateGT))
	}
	if i.StolenDateGTE != nil {
		predicates = append(predicates, car.StolenDateGTE(*i.StolenDateGTE))
	}
	if i.StolenDateLT != nil {
		predicates = append(predicates, car.StolenDateLT(*i.StolenDateLT))
	}
	if i.StolenDateLTE != nil {
		predicates = append(predicates, car.StolenDateLTE(*i.StolenDateLTE))
	}
	if i.StolenDateIsNil {
		predicates = append(predicates, car.StolenDateIsNil())
	}
	if i.StolenDateNotNil {
		predicates = append(predicates, car.StolenDateNotNil())
	}
	if i.FirNumber != nil {
		predicates = append(predicates, car.FirNumberEQ(*i.FirNumber))
	}
	if i.FirNumberNEQ != nil {
		predicates = append(predicates, car.FirNumberNEQ(*i.FirNumberNEQ))
	}
	if len(i.FirNumberIn) > 0 {
		predicates = append(predicates, car.FirNumberIn(i.FirNumberIn...))
	}
	if len(i.FirNumberNotIn) > 0 {
		predicates = append(predicates, car.FirNumberNotIn(i.FirNumberNotIn...))
	}
	if i.FirNumberGT != nil {
		predicates = append(predicates, car.FirNumberGT(*i.FirNumberGT))
	}
	if i.FirNumberGTE != nil {
		predicates = append(predicates, car.FirNumberGTE(*i.FirNumberGTE))
	}
	if i.FirNumberLT != nil {
		predicates = append(predicates, car.FirNumberLT(*i.FirNumberLT))
	}
	if i.FirNumberLTE != nil {
		predicates = append(predicates, car.FirNumberLTE(*i.FirNumberLTE))
	}
	if i.FirNumberContains != nil {
		predicates = append(predicates, car.FirNumberContains(*i.FirNumberContains))
	}
	if i.FirNumberHasPrefix != nil {
		predicates = append(predicates, car.FirNumberHasPrefix(*i.FirNumberHasPrefix))
	}
	if i.FirNumberHasSuffix != nil {
		predicates = append(predicates, car.FirNumberHasSuffix(*i.FirNumberHasSuffix))
	}
	if i.FirNumberIsNil {
		predicates = append(predicates, car.FirNumberIsNil())
	}
	if i.FirNumberNotNil {
		predicates = append(predicates, car.FirNumberNotNil())
	}
	if i.FirNumberEqualFold != nil {
		predicates = append(predicates, car.FirNumberEqualFold(*i.FirNumberEqualFold))
	}
	if i.FirNumberContainsFold != nil {
		predicates = append(predicates, car.FirNumberContainsFold(*i.FirNumberContainsFold))
	}

	if i.HasPoliceStation != nil {
		p := car.HasPoliceStation()
		if !*i.HasPoliceStation {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPoliceStationWith) > 0 {
		with := make([]predicate.PoliceStation, 0, len(i.HasPoliceStationWith))
		for _, w := range i.HasPoliceStationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPoliceStationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasPoliceStationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarWhereInput
	case 1:
		return predicates[0], nil
	default:
		return car.And(predicates...), nil
	}
}

// EventWhereInput represents a where input for filtering Event queries.
type EventWhereInput struct {
	Predicates []predicate.Event  `json:"-"`
	Not        *EventWhereInput   `json:"not,omitempty"`
	Or         []*EventWhereInput `json:"or,omitempty"`
	And        []*EventWhereInput `json:"and,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "plate_channel" field predicates.
	PlateChannel       *int  `json:"plateChannel,omitempty"`
	PlateChannelNEQ    *int  `json:"plateChannelNEQ,omitempty"`
	PlateChannelIn     []int `json:"plateChannelIn,omitempty"`
	PlateChannelNotIn  []int `json:"plateChannelNotIn,omitempty"`
	PlateChannelGT     *int  `json:"plateChannelGT,omitempty"`
	PlateChannelGTE    *int  `json:"plateChannelGTE,omitempty"`
	PlateChannelLT     *int  `json:"plateChannelLT,omitempty"`
	PlateChannelLTE    *int  `json:"plateChannelLTE,omitempty"`
	PlateChannelIsNil  bool  `json:"plateChannelIsNil,omitempty"`
	PlateChannelNotNil bool  `json:"plateChannelNotNil,omitempty"`

	// "plate_is_exist" field predicates.
	PlateIsExist       *bool `json:"plateIsExist,omitempty"`
	PlateIsExistNEQ    *bool `json:"plateIsExistNEQ,omitempty"`
	PlateIsExistIsNil  bool  `json:"plateIsExistIsNil,omitempty"`
	PlateIsExistNotNil bool  `json:"plateIsExistNotNil,omitempty"`

	// "plate_color" field predicates.
	PlateColor             *string  `json:"plateColor,omitempty"`
	PlateColorNEQ          *string  `json:"plateColorNEQ,omitempty"`
	PlateColorIn           []string `json:"plateColorIn,omitempty"`
	PlateColorNotIn        []string `json:"plateColorNotIn,omitempty"`
	PlateColorGT           *string  `json:"plateColorGT,omitempty"`
	PlateColorGTE          *string  `json:"plateColorGTE,omitempty"`
	PlateColorLT           *string  `json:"plateColorLT,omitempty"`
	PlateColorLTE          *string  `json:"plateColorLTE,omitempty"`
	PlateColorContains     *string  `json:"plateColorContains,omitempty"`
	PlateColorHasPrefix    *string  `json:"plateColorHasPrefix,omitempty"`
	PlateColorHasSuffix    *string  `json:"plateColorHasSuffix,omitempty"`
	PlateColorIsNil        bool     `json:"plateColorIsNil,omitempty"`
	PlateColorNotNil       bool     `json:"plateColorNotNil,omitempty"`
	PlateColorEqualFold    *string  `json:"plateColorEqualFold,omitempty"`
	PlateColorContainsFold *string  `json:"plateColorContainsFold,omitempty"`

	// "plate_number" field predicates.
	PlateNumber             *string  `json:"plateNumber,omitempty"`
	PlateNumberNEQ          *string  `json:"plateNumberNEQ,omitempty"`
	PlateNumberIn           []string `json:"plateNumberIn,omitempty"`
	PlateNumberNotIn        []string `json:"plateNumberNotIn,omitempty"`
	PlateNumberGT           *string  `json:"plateNumberGT,omitempty"`
	PlateNumberGTE          *string  `json:"plateNumberGTE,omitempty"`
	PlateNumberLT           *string  `json:"plateNumberLT,omitempty"`
	PlateNumberLTE          *string  `json:"plateNumberLTE,omitempty"`
	PlateNumberContains     *string  `json:"plateNumberContains,omitempty"`
	PlateNumberHasPrefix    *string  `json:"plateNumberHasPrefix,omitempty"`
	PlateNumberHasSuffix    *string  `json:"plateNumberHasSuffix,omitempty"`
	PlateNumberIsNil        bool     `json:"plateNumberIsNil,omitempty"`
	PlateNumberNotNil       bool     `json:"plateNumberNotNil,omitempty"`
	PlateNumberEqualFold    *string  `json:"plateNumberEqualFold,omitempty"`
	PlateNumberContainsFold *string  `json:"plateNumberContainsFold,omitempty"`

	// "plate_type" field predicates.
	PlateType             *string  `json:"plateType,omitempty"`
	PlateTypeNEQ          *string  `json:"plateTypeNEQ,omitempty"`
	PlateTypeIn           []string `json:"plateTypeIn,omitempty"`
	PlateTypeNotIn        []string `json:"plateTypeNotIn,omitempty"`
	PlateTypeGT           *string  `json:"plateTypeGT,omitempty"`
	PlateTypeGTE          *string  `json:"plateTypeGTE,omitempty"`
	PlateTypeLT           *string  `json:"plateTypeLT,omitempty"`
	PlateTypeLTE          *string  `json:"plateTypeLTE,omitempty"`
	PlateTypeContains     *string  `json:"plateTypeContains,omitempty"`
	PlateTypeHasPrefix    *string  `json:"plateTypeHasPrefix,omitempty"`
	PlateTypeHasSuffix    *string  `json:"plateTypeHasSuffix,omitempty"`
	PlateTypeIsNil        bool     `json:"plateTypeIsNil,omitempty"`
	PlateTypeNotNil       bool     `json:"plateTypeNotNil,omitempty"`
	PlateTypeEqualFold    *string  `json:"plateTypeEqualFold,omitempty"`
	PlateTypeContainsFold *string  `json:"plateTypeContainsFold,omitempty"`

	// "plate_region" field predicates.
	PlateRegion             *string  `json:"plateRegion,omitempty"`
	PlateRegionNEQ          *string  `json:"plateRegionNEQ,omitempty"`
	PlateRegionIn           []string `json:"plateRegionIn,omitempty"`
	PlateRegionNotIn        []string `json:"plateRegionNotIn,omitempty"`
	PlateRegionGT           *string  `json:"plateRegionGT,omitempty"`
	PlateRegionGTE          *string  `json:"plateRegionGTE,omitempty"`
	PlateRegionLT           *string  `json:"plateRegionLT,omitempty"`
	PlateRegionLTE          *string  `json:"plateRegionLTE,omitempty"`
	PlateRegionContains     *string  `json:"plateRegionContains,omitempty"`
	PlateRegionHasPrefix    *string  `json:"plateRegionHasPrefix,omitempty"`
	PlateRegionHasSuffix    *string  `json:"plateRegionHasSuffix,omitempty"`
	PlateRegionIsNil        bool     `json:"plateRegionIsNil,omitempty"`
	PlateRegionNotNil       bool     `json:"plateRegionNotNil,omitempty"`
	PlateRegionEqualFold    *string  `json:"plateRegionEqualFold,omitempty"`
	PlateRegionContainsFold *string  `json:"plateRegionContainsFold,omitempty"`

	// "plate_upload_num" field predicates.
	PlateUploadNum       *int  `json:"plateUploadNum,omitempty"`
	PlateUploadNumNEQ    *int  `json:"plateUploadNumNEQ,omitempty"`
	PlateUploadNumIn     []int `json:"plateUploadNumIn,omitempty"`
	PlateUploadNumNotIn  []int `json:"plateUploadNumNotIn,omitempty"`
	PlateUploadNumGT     *int  `json:"plateUploadNumGT,omitempty"`
	PlateUploadNumGTE    *int  `json:"plateUploadNumGTE,omitempty"`
	PlateUploadNumLT     *int  `json:"plateUploadNumLT,omitempty"`
	PlateUploadNumLTE    *int  `json:"plateUploadNumLTE,omitempty"`
	PlateUploadNumIsNil  bool  `json:"plateUploadNumIsNil,omitempty"`
	PlateUploadNumNotNil bool  `json:"plateUploadNumNotNil,omitempty"`

	// "snap_allow_user" field predicates.
	SnapAllowUser       *bool `json:"snapAllowUser,omitempty"`
	SnapAllowUserNEQ    *bool `json:"snapAllowUserNEQ,omitempty"`
	SnapAllowUserIsNil  bool  `json:"snapAllowUserIsNil,omitempty"`
	SnapAllowUserNotNil bool  `json:"snapAllowUserNotNil,omitempty"`

	// "snap_allow_user_end_time" field predicates.
	SnapAllowUserEndTime             *string  `json:"snapAllowUserEndTime,omitempty"`
	SnapAllowUserEndTimeNEQ          *string  `json:"snapAllowUserEndTimeNEQ,omitempty"`
	SnapAllowUserEndTimeIn           []string `json:"snapAllowUserEndTimeIn,omitempty"`
	SnapAllowUserEndTimeNotIn        []string `json:"snapAllowUserEndTimeNotIn,omitempty"`
	SnapAllowUserEndTimeGT           *string  `json:"snapAllowUserEndTimeGT,omitempty"`
	SnapAllowUserEndTimeGTE          *string  `json:"snapAllowUserEndTimeGTE,omitempty"`
	SnapAllowUserEndTimeLT           *string  `json:"snapAllowUserEndTimeLT,omitempty"`
	SnapAllowUserEndTimeLTE          *string  `json:"snapAllowUserEndTimeLTE,omitempty"`
	SnapAllowUserEndTimeContains     *string  `json:"snapAllowUserEndTimeContains,omitempty"`
	SnapAllowUserEndTimeHasPrefix    *string  `json:"snapAllowUserEndTimeHasPrefix,omitempty"`
	SnapAllowUserEndTimeHasSuffix    *string  `json:"snapAllowUserEndTimeHasSuffix,omitempty"`
	SnapAllowUserEndTimeIsNil        bool     `json:"snapAllowUserEndTimeIsNil,omitempty"`
	SnapAllowUserEndTimeNotNil       bool     `json:"snapAllowUserEndTimeNotNil,omitempty"`
	SnapAllowUserEndTimeEqualFold    *string  `json:"snapAllowUserEndTimeEqualFold,omitempty"`
	SnapAllowUserEndTimeContainsFold *string  `json:"snapAllowUserEndTimeContainsFold,omitempty"`

	// "snap_defence_code" field predicates.
	SnapDefenceCode             *string  `json:"snapDefenceCode,omitempty"`
	SnapDefenceCodeNEQ          *string  `json:"snapDefenceCodeNEQ,omitempty"`
	SnapDefenceCodeIn           []string `json:"snapDefenceCodeIn,omitempty"`
	SnapDefenceCodeNotIn        []string `json:"snapDefenceCodeNotIn,omitempty"`
	SnapDefenceCodeGT           *string  `json:"snapDefenceCodeGT,omitempty"`
	SnapDefenceCodeGTE          *string  `json:"snapDefenceCodeGTE,omitempty"`
	SnapDefenceCodeLT           *string  `json:"snapDefenceCodeLT,omitempty"`
	SnapDefenceCodeLTE          *string  `json:"snapDefenceCodeLTE,omitempty"`
	SnapDefenceCodeContains     *string  `json:"snapDefenceCodeContains,omitempty"`
	SnapDefenceCodeHasPrefix    *string  `json:"snapDefenceCodeHasPrefix,omitempty"`
	SnapDefenceCodeHasSuffix    *string  `json:"snapDefenceCodeHasSuffix,omitempty"`
	SnapDefenceCodeIsNil        bool     `json:"snapDefenceCodeIsNil,omitempty"`
	SnapDefenceCodeNotNil       bool     `json:"snapDefenceCodeNotNil,omitempty"`
	SnapDefenceCodeEqualFold    *string  `json:"snapDefenceCodeEqualFold,omitempty"`
	SnapDefenceCodeContainsFold *string  `json:"snapDefenceCodeContainsFold,omitempty"`

	// "snap_device_id" field predicates.
	SnapDeviceID             *string  `json:"snapDeviceID,omitempty"`
	SnapDeviceIDNEQ          *string  `json:"snapDeviceIDNEQ,omitempty"`
	SnapDeviceIDIn           []string `json:"snapDeviceIDIn,omitempty"`
	SnapDeviceIDNotIn        []string `json:"snapDeviceIDNotIn,omitempty"`
	SnapDeviceIDGT           *string  `json:"snapDeviceIDGT,omitempty"`
	SnapDeviceIDGTE          *string  `json:"snapDeviceIDGTE,omitempty"`
	SnapDeviceIDLT           *string  `json:"snapDeviceIDLT,omitempty"`
	SnapDeviceIDLTE          *string  `json:"snapDeviceIDLTE,omitempty"`
	SnapDeviceIDContains     *string  `json:"snapDeviceIDContains,omitempty"`
	SnapDeviceIDHasPrefix    *string  `json:"snapDeviceIDHasPrefix,omitempty"`
	SnapDeviceIDHasSuffix    *string  `json:"snapDeviceIDHasSuffix,omitempty"`
	SnapDeviceIDIsNil        bool     `json:"snapDeviceIDIsNil,omitempty"`
	SnapDeviceIDNotNil       bool     `json:"snapDeviceIDNotNil,omitempty"`
	SnapDeviceIDEqualFold    *string  `json:"snapDeviceIDEqualFold,omitempty"`
	SnapDeviceIDContainsFold *string  `json:"snapDeviceIDContainsFold,omitempty"`

	// "snap_in_car_people_num" field predicates.
	SnapInCarPeopleNum       *int  `json:"snapInCarPeopleNum,omitempty"`
	SnapInCarPeopleNumNEQ    *int  `json:"snapInCarPeopleNumNEQ,omitempty"`
	SnapInCarPeopleNumIn     []int `json:"snapInCarPeopleNumIn,omitempty"`
	SnapInCarPeopleNumNotIn  []int `json:"snapInCarPeopleNumNotIn,omitempty"`
	SnapInCarPeopleNumGT     *int  `json:"snapInCarPeopleNumGT,omitempty"`
	SnapInCarPeopleNumGTE    *int  `json:"snapInCarPeopleNumGTE,omitempty"`
	SnapInCarPeopleNumLT     *int  `json:"snapInCarPeopleNumLT,omitempty"`
	SnapInCarPeopleNumLTE    *int  `json:"snapInCarPeopleNumLTE,omitempty"`
	SnapInCarPeopleNumIsNil  bool  `json:"snapInCarPeopleNumIsNil,omitempty"`
	SnapInCarPeopleNumNotNil bool  `json:"snapInCarPeopleNumNotNil,omitempty"`

	// "snap_lan_no" field predicates.
	SnapLanNo       *int  `json:"snapLanNo,omitempty"`
	SnapLanNoNEQ    *int  `json:"snapLanNoNEQ,omitempty"`
	SnapLanNoIn     []int `json:"snapLanNoIn,omitempty"`
	SnapLanNoNotIn  []int `json:"snapLanNoNotIn,omitempty"`
	SnapLanNoGT     *int  `json:"snapLanNoGT,omitempty"`
	SnapLanNoGTE    *int  `json:"snapLanNoGTE,omitempty"`
	SnapLanNoLT     *int  `json:"snapLanNoLT,omitempty"`
	SnapLanNoLTE    *int  `json:"snapLanNoLTE,omitempty"`
	SnapLanNoIsNil  bool  `json:"snapLanNoIsNil,omitempty"`
	SnapLanNoNotNil bool  `json:"snapLanNoNotNil,omitempty"`

	// "snap_open_strobe" field predicates.
	SnapOpenStrobe       *bool `json:"snapOpenStrobe,omitempty"`
	SnapOpenStrobeNEQ    *bool `json:"snapOpenStrobeNEQ,omitempty"`
	SnapOpenStrobeIsNil  bool  `json:"snapOpenStrobeIsNil,omitempty"`
	SnapOpenStrobeNotNil bool  `json:"snapOpenStrobeNotNil,omitempty"`

	// "vehicle_series" field predicates.
	VehicleSeries             *string  `json:"vehicleSeries,omitempty"`
	VehicleSeriesNEQ          *string  `json:"vehicleSeriesNEQ,omitempty"`
	VehicleSeriesIn           []string `json:"vehicleSeriesIn,omitempty"`
	VehicleSeriesNotIn        []string `json:"vehicleSeriesNotIn,omitempty"`
	VehicleSeriesGT           *string  `json:"vehicleSeriesGT,omitempty"`
	VehicleSeriesGTE          *string  `json:"vehicleSeriesGTE,omitempty"`
	VehicleSeriesLT           *string  `json:"vehicleSeriesLT,omitempty"`
	VehicleSeriesLTE          *string  `json:"vehicleSeriesLTE,omitempty"`
	VehicleSeriesContains     *string  `json:"vehicleSeriesContains,omitempty"`
	VehicleSeriesHasPrefix    *string  `json:"vehicleSeriesHasPrefix,omitempty"`
	VehicleSeriesHasSuffix    *string  `json:"vehicleSeriesHasSuffix,omitempty"`
	VehicleSeriesIsNil        bool     `json:"vehicleSeriesIsNil,omitempty"`
	VehicleSeriesNotNil       bool     `json:"vehicleSeriesNotNil,omitempty"`
	VehicleSeriesEqualFold    *string  `json:"vehicleSeriesEqualFold,omitempty"`
	VehicleSeriesContainsFold *string  `json:"vehicleSeriesContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EventWhereInput) AddPredicates(predicates ...predicate.Event) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EventWhereInput filter on the EventQuery builder.
func (i *EventWhereInput) Filter(q *EventQuery) (*EventQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEventWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEventWhereInput is returned in case the EventWhereInput is empty.
var ErrEmptyEventWhereInput = errors.New("ent: empty predicate EventWhereInput")

// P returns a predicate for filtering events.
// An error is returned if the input is empty or invalid.
func (i *EventWhereInput) P() (predicate.Event, error) {
	var predicates []predicate.Event
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, event.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Event, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, event.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Event, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, event.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.CreatedAt != nil {
		predicates = append(predicates, event.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, event.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, event.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, event.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, event.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, event.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, event.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, event.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.PlateChannel != nil {
		predicates = append(predicates, event.PlateChannelEQ(*i.PlateChannel))
	}
	if i.PlateChannelNEQ != nil {
		predicates = append(predicates, event.PlateChannelNEQ(*i.PlateChannelNEQ))
	}
	if len(i.PlateChannelIn) > 0 {
		predicates = append(predicates, event.PlateChannelIn(i.PlateChannelIn...))
	}
	if len(i.PlateChannelNotIn) > 0 {
		predicates = append(predicates, event.PlateChannelNotIn(i.PlateChannelNotIn...))
	}
	if i.PlateChannelGT != nil {
		predicates = append(predicates, event.PlateChannelGT(*i.PlateChannelGT))
	}
	if i.PlateChannelGTE != nil {
		predicates = append(predicates, event.PlateChannelGTE(*i.PlateChannelGTE))
	}
	if i.PlateChannelLT != nil {
		predicates = append(predicates, event.PlateChannelLT(*i.PlateChannelLT))
	}
	if i.PlateChannelLTE != nil {
		predicates = append(predicates, event.PlateChannelLTE(*i.PlateChannelLTE))
	}
	if i.PlateChannelIsNil {
		predicates = append(predicates, event.PlateChannelIsNil())
	}
	if i.PlateChannelNotNil {
		predicates = append(predicates, event.PlateChannelNotNil())
	}
	if i.PlateIsExist != nil {
		predicates = append(predicates, event.PlateIsExistEQ(*i.PlateIsExist))
	}
	if i.PlateIsExistNEQ != nil {
		predicates = append(predicates, event.PlateIsExistNEQ(*i.PlateIsExistNEQ))
	}
	if i.PlateIsExistIsNil {
		predicates = append(predicates, event.PlateIsExistIsNil())
	}
	if i.PlateIsExistNotNil {
		predicates = append(predicates, event.PlateIsExistNotNil())
	}
	if i.PlateColor != nil {
		predicates = append(predicates, event.PlateColorEQ(*i.PlateColor))
	}
	if i.PlateColorNEQ != nil {
		predicates = append(predicates, event.PlateColorNEQ(*i.PlateColorNEQ))
	}
	if len(i.PlateColorIn) > 0 {
		predicates = append(predicates, event.PlateColorIn(i.PlateColorIn...))
	}
	if len(i.PlateColorNotIn) > 0 {
		predicates = append(predicates, event.PlateColorNotIn(i.PlateColorNotIn...))
	}
	if i.PlateColorGT != nil {
		predicates = append(predicates, event.PlateColorGT(*i.PlateColorGT))
	}
	if i.PlateColorGTE != nil {
		predicates = append(predicates, event.PlateColorGTE(*i.PlateColorGTE))
	}
	if i.PlateColorLT != nil {
		predicates = append(predicates, event.PlateColorLT(*i.PlateColorLT))
	}
	if i.PlateColorLTE != nil {
		predicates = append(predicates, event.PlateColorLTE(*i.PlateColorLTE))
	}
	if i.PlateColorContains != nil {
		predicates = append(predicates, event.PlateColorContains(*i.PlateColorContains))
	}
	if i.PlateColorHasPrefix != nil {
		predicates = append(predicates, event.PlateColorHasPrefix(*i.PlateColorHasPrefix))
	}
	if i.PlateColorHasSuffix != nil {
		predicates = append(predicates, event.PlateColorHasSuffix(*i.PlateColorHasSuffix))
	}
	if i.PlateColorIsNil {
		predicates = append(predicates, event.PlateColorIsNil())
	}
	if i.PlateColorNotNil {
		predicates = append(predicates, event.PlateColorNotNil())
	}
	if i.PlateColorEqualFold != nil {
		predicates = append(predicates, event.PlateColorEqualFold(*i.PlateColorEqualFold))
	}
	if i.PlateColorContainsFold != nil {
		predicates = append(predicates, event.PlateColorContainsFold(*i.PlateColorContainsFold))
	}
	if i.PlateNumber != nil {
		predicates = append(predicates, event.PlateNumberEQ(*i.PlateNumber))
	}
	if i.PlateNumberNEQ != nil {
		predicates = append(predicates, event.PlateNumberNEQ(*i.PlateNumberNEQ))
	}
	if len(i.PlateNumberIn) > 0 {
		predicates = append(predicates, event.PlateNumberIn(i.PlateNumberIn...))
	}
	if len(i.PlateNumberNotIn) > 0 {
		predicates = append(predicates, event.PlateNumberNotIn(i.PlateNumberNotIn...))
	}
	if i.PlateNumberGT != nil {
		predicates = append(predicates, event.PlateNumberGT(*i.PlateNumberGT))
	}
	if i.PlateNumberGTE != nil {
		predicates = append(predicates, event.PlateNumberGTE(*i.PlateNumberGTE))
	}
	if i.PlateNumberLT != nil {
		predicates = append(predicates, event.PlateNumberLT(*i.PlateNumberLT))
	}
	if i.PlateNumberLTE != nil {
		predicates = append(predicates, event.PlateNumberLTE(*i.PlateNumberLTE))
	}
	if i.PlateNumberContains != nil {
		predicates = append(predicates, event.PlateNumberContains(*i.PlateNumberContains))
	}
	if i.PlateNumberHasPrefix != nil {
		predicates = append(predicates, event.PlateNumberHasPrefix(*i.PlateNumberHasPrefix))
	}
	if i.PlateNumberHasSuffix != nil {
		predicates = append(predicates, event.PlateNumberHasSuffix(*i.PlateNumberHasSuffix))
	}
	if i.PlateNumberIsNil {
		predicates = append(predicates, event.PlateNumberIsNil())
	}
	if i.PlateNumberNotNil {
		predicates = append(predicates, event.PlateNumberNotNil())
	}
	if i.PlateNumberEqualFold != nil {
		predicates = append(predicates, event.PlateNumberEqualFold(*i.PlateNumberEqualFold))
	}
	if i.PlateNumberContainsFold != nil {
		predicates = append(predicates, event.PlateNumberContainsFold(*i.PlateNumberContainsFold))
	}
	if i.PlateType != nil {
		predicates = append(predicates, event.PlateTypeEQ(*i.PlateType))
	}
	if i.PlateTypeNEQ != nil {
		predicates = append(predicates, event.PlateTypeNEQ(*i.PlateTypeNEQ))
	}
	if len(i.PlateTypeIn) > 0 {
		predicates = append(predicates, event.PlateTypeIn(i.PlateTypeIn...))
	}
	if len(i.PlateTypeNotIn) > 0 {
		predicates = append(predicates, event.PlateTypeNotIn(i.PlateTypeNotIn...))
	}
	if i.PlateTypeGT != nil {
		predicates = append(predicates, event.PlateTypeGT(*i.PlateTypeGT))
	}
	if i.PlateTypeGTE != nil {
		predicates = append(predicates, event.PlateTypeGTE(*i.PlateTypeGTE))
	}
	if i.PlateTypeLT != nil {
		predicates = append(predicates, event.PlateTypeLT(*i.PlateTypeLT))
	}
	if i.PlateTypeLTE != nil {
		predicates = append(predicates, event.PlateTypeLTE(*i.PlateTypeLTE))
	}
	if i.PlateTypeContains != nil {
		predicates = append(predicates, event.PlateTypeContains(*i.PlateTypeContains))
	}
	if i.PlateTypeHasPrefix != nil {
		predicates = append(predicates, event.PlateTypeHasPrefix(*i.PlateTypeHasPrefix))
	}
	if i.PlateTypeHasSuffix != nil {
		predicates = append(predicates, event.PlateTypeHasSuffix(*i.PlateTypeHasSuffix))
	}
	if i.PlateTypeIsNil {
		predicates = append(predicates, event.PlateTypeIsNil())
	}
	if i.PlateTypeNotNil {
		predicates = append(predicates, event.PlateTypeNotNil())
	}
	if i.PlateTypeEqualFold != nil {
		predicates = append(predicates, event.PlateTypeEqualFold(*i.PlateTypeEqualFold))
	}
	if i.PlateTypeContainsFold != nil {
		predicates = append(predicates, event.PlateTypeContainsFold(*i.PlateTypeContainsFold))
	}
	if i.PlateRegion != nil {
		predicates = append(predicates, event.PlateRegionEQ(*i.PlateRegion))
	}
	if i.PlateRegionNEQ != nil {
		predicates = append(predicates, event.PlateRegionNEQ(*i.PlateRegionNEQ))
	}
	if len(i.PlateRegionIn) > 0 {
		predicates = append(predicates, event.PlateRegionIn(i.PlateRegionIn...))
	}
	if len(i.PlateRegionNotIn) > 0 {
		predicates = append(predicates, event.PlateRegionNotIn(i.PlateRegionNotIn...))
	}
	if i.PlateRegionGT != nil {
		predicates = append(predicates, event.PlateRegionGT(*i.PlateRegionGT))
	}
	if i.PlateRegionGTE != nil {
		predicates = append(predicates, event.PlateRegionGTE(*i.PlateRegionGTE))
	}
	if i.PlateRegionLT != nil {
		predicates = append(predicates, event.PlateRegionLT(*i.PlateRegionLT))
	}
	if i.PlateRegionLTE != nil {
		predicates = append(predicates, event.PlateRegionLTE(*i.PlateRegionLTE))
	}
	if i.PlateRegionContains != nil {
		predicates = append(predicates, event.PlateRegionContains(*i.PlateRegionContains))
	}
	if i.PlateRegionHasPrefix != nil {
		predicates = append(predicates, event.PlateRegionHasPrefix(*i.PlateRegionHasPrefix))
	}
	if i.PlateRegionHasSuffix != nil {
		predicates = append(predicates, event.PlateRegionHasSuffix(*i.PlateRegionHasSuffix))
	}
	if i.PlateRegionIsNil {
		predicates = append(predicates, event.PlateRegionIsNil())
	}
	if i.PlateRegionNotNil {
		predicates = append(predicates, event.PlateRegionNotNil())
	}
	if i.PlateRegionEqualFold != nil {
		predicates = append(predicates, event.PlateRegionEqualFold(*i.PlateRegionEqualFold))
	}
	if i.PlateRegionContainsFold != nil {
		predicates = append(predicates, event.PlateRegionContainsFold(*i.PlateRegionContainsFold))
	}
	if i.PlateUploadNum != nil {
		predicates = append(predicates, event.PlateUploadNumEQ(*i.PlateUploadNum))
	}
	if i.PlateUploadNumNEQ != nil {
		predicates = append(predicates, event.PlateUploadNumNEQ(*i.PlateUploadNumNEQ))
	}
	if len(i.PlateUploadNumIn) > 0 {
		predicates = append(predicates, event.PlateUploadNumIn(i.PlateUploadNumIn...))
	}
	if len(i.PlateUploadNumNotIn) > 0 {
		predicates = append(predicates, event.PlateUploadNumNotIn(i.PlateUploadNumNotIn...))
	}
	if i.PlateUploadNumGT != nil {
		predicates = append(predicates, event.PlateUploadNumGT(*i.PlateUploadNumGT))
	}
	if i.PlateUploadNumGTE != nil {
		predicates = append(predicates, event.PlateUploadNumGTE(*i.PlateUploadNumGTE))
	}
	if i.PlateUploadNumLT != nil {
		predicates = append(predicates, event.PlateUploadNumLT(*i.PlateUploadNumLT))
	}
	if i.PlateUploadNumLTE != nil {
		predicates = append(predicates, event.PlateUploadNumLTE(*i.PlateUploadNumLTE))
	}
	if i.PlateUploadNumIsNil {
		predicates = append(predicates, event.PlateUploadNumIsNil())
	}
	if i.PlateUploadNumNotNil {
		predicates = append(predicates, event.PlateUploadNumNotNil())
	}
	if i.SnapAllowUser != nil {
		predicates = append(predicates, event.SnapAllowUserEQ(*i.SnapAllowUser))
	}
	if i.SnapAllowUserNEQ != nil {
		predicates = append(predicates, event.SnapAllowUserNEQ(*i.SnapAllowUserNEQ))
	}
	if i.SnapAllowUserIsNil {
		predicates = append(predicates, event.SnapAllowUserIsNil())
	}
	if i.SnapAllowUserNotNil {
		predicates = append(predicates, event.SnapAllowUserNotNil())
	}
	if i.SnapAllowUserEndTime != nil {
		predicates = append(predicates, event.SnapAllowUserEndTimeEQ(*i.SnapAllowUserEndTime))
	}
	if i.SnapAllowUserEndTimeNEQ != nil {
		predicates = append(predicates, event.SnapAllowUserEndTimeNEQ(*i.SnapAllowUserEndTimeNEQ))
	}
	if len(i.SnapAllowUserEndTimeIn) > 0 {
		predicates = append(predicates, event.SnapAllowUserEndTimeIn(i.SnapAllowUserEndTimeIn...))
	}
	if len(i.SnapAllowUserEndTimeNotIn) > 0 {
		predicates = append(predicates, event.SnapAllowUserEndTimeNotIn(i.SnapAllowUserEndTimeNotIn...))
	}
	if i.SnapAllowUserEndTimeGT != nil {
		predicates = append(predicates, event.SnapAllowUserEndTimeGT(*i.SnapAllowUserEndTimeGT))
	}
	if i.SnapAllowUserEndTimeGTE != nil {
		predicates = append(predicates, event.SnapAllowUserEndTimeGTE(*i.SnapAllowUserEndTimeGTE))
	}
	if i.SnapAllowUserEndTimeLT != nil {
		predicates = append(predicates, event.SnapAllowUserEndTimeLT(*i.SnapAllowUserEndTimeLT))
	}
	if i.SnapAllowUserEndTimeLTE != nil {
		predicates = append(predicates, event.SnapAllowUserEndTimeLTE(*i.SnapAllowUserEndTimeLTE))
	}
	if i.SnapAllowUserEndTimeContains != nil {
		predicates = append(predicates, event.SnapAllowUserEndTimeContains(*i.SnapAllowUserEndTimeContains))
	}
	if i.SnapAllowUserEndTimeHasPrefix != nil {
		predicates = append(predicates, event.SnapAllowUserEndTimeHasPrefix(*i.SnapAllowUserEndTimeHasPrefix))
	}
	if i.SnapAllowUserEndTimeHasSuffix != nil {
		predicates = append(predicates, event.SnapAllowUserEndTimeHasSuffix(*i.SnapAllowUserEndTimeHasSuffix))
	}
	if i.SnapAllowUserEndTimeIsNil {
		predicates = append(predicates, event.SnapAllowUserEndTimeIsNil())
	}
	if i.SnapAllowUserEndTimeNotNil {
		predicates = append(predicates, event.SnapAllowUserEndTimeNotNil())
	}
	if i.SnapAllowUserEndTimeEqualFold != nil {
		predicates = append(predicates, event.SnapAllowUserEndTimeEqualFold(*i.SnapAllowUserEndTimeEqualFold))
	}
	if i.SnapAllowUserEndTimeContainsFold != nil {
		predicates = append(predicates, event.SnapAllowUserEndTimeContainsFold(*i.SnapAllowUserEndTimeContainsFold))
	}
	if i.SnapDefenceCode != nil {
		predicates = append(predicates, event.SnapDefenceCodeEQ(*i.SnapDefenceCode))
	}
	if i.SnapDefenceCodeNEQ != nil {
		predicates = append(predicates, event.SnapDefenceCodeNEQ(*i.SnapDefenceCodeNEQ))
	}
	if len(i.SnapDefenceCodeIn) > 0 {
		predicates = append(predicates, event.SnapDefenceCodeIn(i.SnapDefenceCodeIn...))
	}
	if len(i.SnapDefenceCodeNotIn) > 0 {
		predicates = append(predicates, event.SnapDefenceCodeNotIn(i.SnapDefenceCodeNotIn...))
	}
	if i.SnapDefenceCodeGT != nil {
		predicates = append(predicates, event.SnapDefenceCodeGT(*i.SnapDefenceCodeGT))
	}
	if i.SnapDefenceCodeGTE != nil {
		predicates = append(predicates, event.SnapDefenceCodeGTE(*i.SnapDefenceCodeGTE))
	}
	if i.SnapDefenceCodeLT != nil {
		predicates = append(predicates, event.SnapDefenceCodeLT(*i.SnapDefenceCodeLT))
	}
	if i.SnapDefenceCodeLTE != nil {
		predicates = append(predicates, event.SnapDefenceCodeLTE(*i.SnapDefenceCodeLTE))
	}
	if i.SnapDefenceCodeContains != nil {
		predicates = append(predicates, event.SnapDefenceCodeContains(*i.SnapDefenceCodeContains))
	}
	if i.SnapDefenceCodeHasPrefix != nil {
		predicates = append(predicates, event.SnapDefenceCodeHasPrefix(*i.SnapDefenceCodeHasPrefix))
	}
	if i.SnapDefenceCodeHasSuffix != nil {
		predicates = append(predicates, event.SnapDefenceCodeHasSuffix(*i.SnapDefenceCodeHasSuffix))
	}
	if i.SnapDefenceCodeIsNil {
		predicates = append(predicates, event.SnapDefenceCodeIsNil())
	}
	if i.SnapDefenceCodeNotNil {
		predicates = append(predicates, event.SnapDefenceCodeNotNil())
	}
	if i.SnapDefenceCodeEqualFold != nil {
		predicates = append(predicates, event.SnapDefenceCodeEqualFold(*i.SnapDefenceCodeEqualFold))
	}
	if i.SnapDefenceCodeContainsFold != nil {
		predicates = append(predicates, event.SnapDefenceCodeContainsFold(*i.SnapDefenceCodeContainsFold))
	}
	if i.SnapDeviceID != nil {
		predicates = append(predicates, event.SnapDeviceIDEQ(*i.SnapDeviceID))
	}
	if i.SnapDeviceIDNEQ != nil {
		predicates = append(predicates, event.SnapDeviceIDNEQ(*i.SnapDeviceIDNEQ))
	}
	if len(i.SnapDeviceIDIn) > 0 {
		predicates = append(predicates, event.SnapDeviceIDIn(i.SnapDeviceIDIn...))
	}
	if len(i.SnapDeviceIDNotIn) > 0 {
		predicates = append(predicates, event.SnapDeviceIDNotIn(i.SnapDeviceIDNotIn...))
	}
	if i.SnapDeviceIDGT != nil {
		predicates = append(predicates, event.SnapDeviceIDGT(*i.SnapDeviceIDGT))
	}
	if i.SnapDeviceIDGTE != nil {
		predicates = append(predicates, event.SnapDeviceIDGTE(*i.SnapDeviceIDGTE))
	}
	if i.SnapDeviceIDLT != nil {
		predicates = append(predicates, event.SnapDeviceIDLT(*i.SnapDeviceIDLT))
	}
	if i.SnapDeviceIDLTE != nil {
		predicates = append(predicates, event.SnapDeviceIDLTE(*i.SnapDeviceIDLTE))
	}
	if i.SnapDeviceIDContains != nil {
		predicates = append(predicates, event.SnapDeviceIDContains(*i.SnapDeviceIDContains))
	}
	if i.SnapDeviceIDHasPrefix != nil {
		predicates = append(predicates, event.SnapDeviceIDHasPrefix(*i.SnapDeviceIDHasPrefix))
	}
	if i.SnapDeviceIDHasSuffix != nil {
		predicates = append(predicates, event.SnapDeviceIDHasSuffix(*i.SnapDeviceIDHasSuffix))
	}
	if i.SnapDeviceIDIsNil {
		predicates = append(predicates, event.SnapDeviceIDIsNil())
	}
	if i.SnapDeviceIDNotNil {
		predicates = append(predicates, event.SnapDeviceIDNotNil())
	}
	if i.SnapDeviceIDEqualFold != nil {
		predicates = append(predicates, event.SnapDeviceIDEqualFold(*i.SnapDeviceIDEqualFold))
	}
	if i.SnapDeviceIDContainsFold != nil {
		predicates = append(predicates, event.SnapDeviceIDContainsFold(*i.SnapDeviceIDContainsFold))
	}
	if i.SnapInCarPeopleNum != nil {
		predicates = append(predicates, event.SnapInCarPeopleNumEQ(*i.SnapInCarPeopleNum))
	}
	if i.SnapInCarPeopleNumNEQ != nil {
		predicates = append(predicates, event.SnapInCarPeopleNumNEQ(*i.SnapInCarPeopleNumNEQ))
	}
	if len(i.SnapInCarPeopleNumIn) > 0 {
		predicates = append(predicates, event.SnapInCarPeopleNumIn(i.SnapInCarPeopleNumIn...))
	}
	if len(i.SnapInCarPeopleNumNotIn) > 0 {
		predicates = append(predicates, event.SnapInCarPeopleNumNotIn(i.SnapInCarPeopleNumNotIn...))
	}
	if i.SnapInCarPeopleNumGT != nil {
		predicates = append(predicates, event.SnapInCarPeopleNumGT(*i.SnapInCarPeopleNumGT))
	}
	if i.SnapInCarPeopleNumGTE != nil {
		predicates = append(predicates, event.SnapInCarPeopleNumGTE(*i.SnapInCarPeopleNumGTE))
	}
	if i.SnapInCarPeopleNumLT != nil {
		predicates = append(predicates, event.SnapInCarPeopleNumLT(*i.SnapInCarPeopleNumLT))
	}
	if i.SnapInCarPeopleNumLTE != nil {
		predicates = append(predicates, event.SnapInCarPeopleNumLTE(*i.SnapInCarPeopleNumLTE))
	}
	if i.SnapInCarPeopleNumIsNil {
		predicates = append(predicates, event.SnapInCarPeopleNumIsNil())
	}
	if i.SnapInCarPeopleNumNotNil {
		predicates = append(predicates, event.SnapInCarPeopleNumNotNil())
	}
	if i.SnapLanNo != nil {
		predicates = append(predicates, event.SnapLanNoEQ(*i.SnapLanNo))
	}
	if i.SnapLanNoNEQ != nil {
		predicates = append(predicates, event.SnapLanNoNEQ(*i.SnapLanNoNEQ))
	}
	if len(i.SnapLanNoIn) > 0 {
		predicates = append(predicates, event.SnapLanNoIn(i.SnapLanNoIn...))
	}
	if len(i.SnapLanNoNotIn) > 0 {
		predicates = append(predicates, event.SnapLanNoNotIn(i.SnapLanNoNotIn...))
	}
	if i.SnapLanNoGT != nil {
		predicates = append(predicates, event.SnapLanNoGT(*i.SnapLanNoGT))
	}
	if i.SnapLanNoGTE != nil {
		predicates = append(predicates, event.SnapLanNoGTE(*i.SnapLanNoGTE))
	}
	if i.SnapLanNoLT != nil {
		predicates = append(predicates, event.SnapLanNoLT(*i.SnapLanNoLT))
	}
	if i.SnapLanNoLTE != nil {
		predicates = append(predicates, event.SnapLanNoLTE(*i.SnapLanNoLTE))
	}
	if i.SnapLanNoIsNil {
		predicates = append(predicates, event.SnapLanNoIsNil())
	}
	if i.SnapLanNoNotNil {
		predicates = append(predicates, event.SnapLanNoNotNil())
	}
	if i.SnapOpenStrobe != nil {
		predicates = append(predicates, event.SnapOpenStrobeEQ(*i.SnapOpenStrobe))
	}
	if i.SnapOpenStrobeNEQ != nil {
		predicates = append(predicates, event.SnapOpenStrobeNEQ(*i.SnapOpenStrobeNEQ))
	}
	if i.SnapOpenStrobeIsNil {
		predicates = append(predicates, event.SnapOpenStrobeIsNil())
	}
	if i.SnapOpenStrobeNotNil {
		predicates = append(predicates, event.SnapOpenStrobeNotNil())
	}
	if i.VehicleSeries != nil {
		predicates = append(predicates, event.VehicleSeriesEQ(*i.VehicleSeries))
	}
	if i.VehicleSeriesNEQ != nil {
		predicates = append(predicates, event.VehicleSeriesNEQ(*i.VehicleSeriesNEQ))
	}
	if len(i.VehicleSeriesIn) > 0 {
		predicates = append(predicates, event.VehicleSeriesIn(i.VehicleSeriesIn...))
	}
	if len(i.VehicleSeriesNotIn) > 0 {
		predicates = append(predicates, event.VehicleSeriesNotIn(i.VehicleSeriesNotIn...))
	}
	if i.VehicleSeriesGT != nil {
		predicates = append(predicates, event.VehicleSeriesGT(*i.VehicleSeriesGT))
	}
	if i.VehicleSeriesGTE != nil {
		predicates = append(predicates, event.VehicleSeriesGTE(*i.VehicleSeriesGTE))
	}
	if i.VehicleSeriesLT != nil {
		predicates = append(predicates, event.VehicleSeriesLT(*i.VehicleSeriesLT))
	}
	if i.VehicleSeriesLTE != nil {
		predicates = append(predicates, event.VehicleSeriesLTE(*i.VehicleSeriesLTE))
	}
	if i.VehicleSeriesContains != nil {
		predicates = append(predicates, event.VehicleSeriesContains(*i.VehicleSeriesContains))
	}
	if i.VehicleSeriesHasPrefix != nil {
		predicates = append(predicates, event.VehicleSeriesHasPrefix(*i.VehicleSeriesHasPrefix))
	}
	if i.VehicleSeriesHasSuffix != nil {
		predicates = append(predicates, event.VehicleSeriesHasSuffix(*i.VehicleSeriesHasSuffix))
	}
	if i.VehicleSeriesIsNil {
		predicates = append(predicates, event.VehicleSeriesIsNil())
	}
	if i.VehicleSeriesNotNil {
		predicates = append(predicates, event.VehicleSeriesNotNil())
	}
	if i.VehicleSeriesEqualFold != nil {
		predicates = append(predicates, event.VehicleSeriesEqualFold(*i.VehicleSeriesEqualFold))
	}
	if i.VehicleSeriesContainsFold != nil {
		predicates = append(predicates, event.VehicleSeriesContainsFold(*i.VehicleSeriesContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEventWhereInput
	case 1:
		return predicates[0], nil
	default:
		return event.And(predicates...), nil
	}
}

// PermissionWhereInput represents a where input for filtering Permission queries.
type PermissionWhereInput struct {
	Predicates []predicate.Permission  `json:"-"`
	Not        *PermissionWhereInput   `json:"not,omitempty"`
	Or         []*PermissionWhereInput `json:"or,omitempty"`
	And        []*PermissionWhereInput `json:"and,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PermissionWhereInput) AddPredicates(predicates ...predicate.Permission) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PermissionWhereInput filter on the PermissionQuery builder.
func (i *PermissionWhereInput) Filter(q *PermissionQuery) (*PermissionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPermissionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPermissionWhereInput is returned in case the PermissionWhereInput is empty.
var ErrEmptyPermissionWhereInput = errors.New("ent: empty predicate PermissionWhereInput")

// P returns a predicate for filtering permissions.
// An error is returned if the input is empty or invalid.
func (i *PermissionWhereInput) P() (predicate.Permission, error) {
	var predicates []predicate.Permission
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, permission.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Permission, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, permission.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Permission, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, permission.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.CreatedAt != nil {
		predicates = append(predicates, permission.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, permission.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, permission.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, permission.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, permission.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, permission.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, permission.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, permission.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, permission.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, permission.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, permission.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, permission.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, permission.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, permission.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, permission.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, permission.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, permission.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, permission.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, permission.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, permission.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, permission.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPermissionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return permission.And(predicates...), nil
	}
}

// PoliceStationWhereInput represents a where input for filtering PoliceStation queries.
type PoliceStationWhereInput struct {
	Predicates []predicate.PoliceStation  `json:"-"`
	Not        *PoliceStationWhereInput   `json:"not,omitempty"`
	Or         []*PoliceStationWhereInput `json:"or,omitempty"`
	And        []*PoliceStationWhereInput `json:"and,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "identifier" field predicates.
	Identifier             *string  `json:"identifier,omitempty"`
	IdentifierNEQ          *string  `json:"identifierNEQ,omitempty"`
	IdentifierIn           []string `json:"identifierIn,omitempty"`
	IdentifierNotIn        []string `json:"identifierNotIn,omitempty"`
	IdentifierGT           *string  `json:"identifierGT,omitempty"`
	IdentifierGTE          *string  `json:"identifierGTE,omitempty"`
	IdentifierLT           *string  `json:"identifierLT,omitempty"`
	IdentifierLTE          *string  `json:"identifierLTE,omitempty"`
	IdentifierContains     *string  `json:"identifierContains,omitempty"`
	IdentifierHasPrefix    *string  `json:"identifierHasPrefix,omitempty"`
	IdentifierHasSuffix    *string  `json:"identifierHasSuffix,omitempty"`
	IdentifierEqualFold    *string  `json:"identifierEqualFold,omitempty"`
	IdentifierContainsFold *string  `json:"identifierContainsFold,omitempty"`

	// "parent_station_id" field predicates.
	ParentStationID       *uuid.UUID  `json:"parentStationID,omitempty"`
	ParentStationIDNEQ    *uuid.UUID  `json:"parentStationIDNEQ,omitempty"`
	ParentStationIDIn     []uuid.UUID `json:"parentStationIDIn,omitempty"`
	ParentStationIDNotIn  []uuid.UUID `json:"parentStationIDNotIn,omitempty"`
	ParentStationIDIsNil  bool        `json:"parentStationIDIsNil,omitempty"`
	ParentStationIDNotNil bool        `json:"parentStationIDNotNil,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "camera" edge predicates.
	HasCamera     *bool               `json:"hasCamera,omitempty"`
	HasCameraWith []*CameraWhereInput `json:"hasCameraWith,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool                      `json:"hasParent,omitempty"`
	HasParentWith []*PoliceStationWhereInput `json:"hasParentWith,omitempty"`

	// "child_stations" edge predicates.
	HasChildStations     *bool                      `json:"hasChildStations,omitempty"`
	HasChildStationsWith []*PoliceStationWhereInput `json:"hasChildStationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PoliceStationWhereInput) AddPredicates(predicates ...predicate.PoliceStation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PoliceStationWhereInput filter on the PoliceStationQuery builder.
func (i *PoliceStationWhereInput) Filter(q *PoliceStationQuery) (*PoliceStationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPoliceStationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPoliceStationWhereInput is returned in case the PoliceStationWhereInput is empty.
var ErrEmptyPoliceStationWhereInput = errors.New("ent: empty predicate PoliceStationWhereInput")

// P returns a predicate for filtering policestations.
// An error is returned if the input is empty or invalid.
func (i *PoliceStationWhereInput) P() (predicate.PoliceStation, error) {
	var predicates []predicate.PoliceStation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, policestation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PoliceStation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, policestation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PoliceStation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, policestation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.CreatedAt != nil {
		predicates = append(predicates, policestation.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, policestation.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, policestation.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, policestation.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, policestation.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, policestation.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, policestation.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, policestation.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, policestation.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, policestation.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, policestation.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, policestation.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, policestation.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, policestation.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, policestation.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, policestation.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, policestation.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, policestation.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, policestation.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, policestation.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, policestation.NameContainsFold(*i.NameContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, policestation.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, policestation.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, policestation.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, policestation.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, policestation.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, policestation.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, policestation.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, policestation.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, policestation.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, policestation.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, policestation.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, policestation.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, policestation.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Identifier != nil {
		predicates = append(predicates, policestation.IdentifierEQ(*i.Identifier))
	}
	if i.IdentifierNEQ != nil {
		predicates = append(predicates, policestation.IdentifierNEQ(*i.IdentifierNEQ))
	}
	if len(i.IdentifierIn) > 0 {
		predicates = append(predicates, policestation.IdentifierIn(i.IdentifierIn...))
	}
	if len(i.IdentifierNotIn) > 0 {
		predicates = append(predicates, policestation.IdentifierNotIn(i.IdentifierNotIn...))
	}
	if i.IdentifierGT != nil {
		predicates = append(predicates, policestation.IdentifierGT(*i.IdentifierGT))
	}
	if i.IdentifierGTE != nil {
		predicates = append(predicates, policestation.IdentifierGTE(*i.IdentifierGTE))
	}
	if i.IdentifierLT != nil {
		predicates = append(predicates, policestation.IdentifierLT(*i.IdentifierLT))
	}
	if i.IdentifierLTE != nil {
		predicates = append(predicates, policestation.IdentifierLTE(*i.IdentifierLTE))
	}
	if i.IdentifierContains != nil {
		predicates = append(predicates, policestation.IdentifierContains(*i.IdentifierContains))
	}
	if i.IdentifierHasPrefix != nil {
		predicates = append(predicates, policestation.IdentifierHasPrefix(*i.IdentifierHasPrefix))
	}
	if i.IdentifierHasSuffix != nil {
		predicates = append(predicates, policestation.IdentifierHasSuffix(*i.IdentifierHasSuffix))
	}
	if i.IdentifierEqualFold != nil {
		predicates = append(predicates, policestation.IdentifierEqualFold(*i.IdentifierEqualFold))
	}
	if i.IdentifierContainsFold != nil {
		predicates = append(predicates, policestation.IdentifierContainsFold(*i.IdentifierContainsFold))
	}
	if i.ParentStationID != nil {
		predicates = append(predicates, policestation.ParentStationIDEQ(*i.ParentStationID))
	}
	if i.ParentStationIDNEQ != nil {
		predicates = append(predicates, policestation.ParentStationIDNEQ(*i.ParentStationIDNEQ))
	}
	if len(i.ParentStationIDIn) > 0 {
		predicates = append(predicates, policestation.ParentStationIDIn(i.ParentStationIDIn...))
	}
	if len(i.ParentStationIDNotIn) > 0 {
		predicates = append(predicates, policestation.ParentStationIDNotIn(i.ParentStationIDNotIn...))
	}
	if i.ParentStationIDIsNil {
		predicates = append(predicates, policestation.ParentStationIDIsNil())
	}
	if i.ParentStationIDNotNil {
		predicates = append(predicates, policestation.ParentStationIDNotNil())
	}

	if i.HasUsers != nil {
		p := policestation.HasUsers()
		if !*i.HasUsers {
			p = policestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, policestation.HasUsersWith(with...))
	}
	if i.HasCamera != nil {
		p := policestation.HasCamera()
		if !*i.HasCamera {
			p = policestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCameraWith) > 0 {
		with := make([]predicate.Camera, 0, len(i.HasCameraWith))
		for _, w := range i.HasCameraWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCameraWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, policestation.HasCameraWith(with...))
	}
	if i.HasCar != nil {
		p := policestation.HasCar()
		if !*i.HasCar {
			p = policestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, policestation.HasCarWith(with...))
	}
	if i.HasParent != nil {
		p := policestation.HasParent()
		if !*i.HasParent {
			p = policestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.PoliceStation, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, policestation.HasParentWith(with...))
	}
	if i.HasChildStations != nil {
		p := policestation.HasChildStations()
		if !*i.HasChildStations {
			p = policestation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildStationsWith) > 0 {
		with := make([]predicate.PoliceStation, 0, len(i.HasChildStationsWith))
		for _, w := range i.HasChildStationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildStationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, policestation.HasChildStationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPoliceStationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return policestation.And(predicates...), nil
	}
}

// RoleWhereInput represents a where input for filtering Role queries.
type RoleWhereInput struct {
	Predicates []predicate.Role  `json:"-"`
	Not        *RoleWhereInput   `json:"not,omitempty"`
	Or         []*RoleWhereInput `json:"or,omitempty"`
	And        []*RoleWhereInput `json:"and,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "permissions" edge predicates.
	HasPermissions     *bool                   `json:"hasPermissions,omitempty"`
	HasPermissionsWith []*PermissionWhereInput `json:"hasPermissionsWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoleWhereInput) AddPredicates(predicates ...predicate.Role) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoleWhereInput filter on the RoleQuery builder.
func (i *RoleWhereInput) Filter(q *RoleQuery) (*RoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoleWhereInput is returned in case the RoleWhereInput is empty.
var ErrEmptyRoleWhereInput = errors.New("ent: empty predicate RoleWhereInput")

// P returns a predicate for filtering roles.
// An error is returned if the input is empty or invalid.
func (i *RoleWhereInput) P() (predicate.Role, error) {
	var predicates []predicate.Role
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, role.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Role, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, role.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Role, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, role.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.CreatedAt != nil {
		predicates = append(predicates, role.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, role.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, role.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, role.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, role.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, role.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, role.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, role.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, role.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, role.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, role.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, role.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, role.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, role.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, role.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, role.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, role.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, role.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, role.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, role.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, role.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasPermissions != nil {
		p := role.HasPermissions()
		if !*i.HasPermissions {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPermissionsWith) > 0 {
		with := make([]predicate.Permission, 0, len(i.HasPermissionsWith))
		for _, w := range i.HasPermissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPermissionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasPermissionsWith(with...))
	}
	if i.HasUsers != nil {
		p := role.HasUsers()
		if !*i.HasUsers {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return role.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "role" edge predicates.
	HasRole     *bool             `json:"hasRole,omitempty"`
	HasRoleWith []*RoleWhereInput `json:"hasRoleWith,omitempty"`

	// "police_station" edge predicates.
	HasPoliceStation     *bool                      `json:"hasPoliceStation,omitempty"`
	HasPoliceStationWith []*PoliceStationWhereInput `json:"hasPoliceStationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, user.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, user.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, user.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, user.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, user.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, user.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, user.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, user.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, user.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, user.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, user.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, user.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, user.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, user.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, user.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, user.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, user.ActiveNEQ(*i.ActiveNEQ))
	}

	if i.HasRole != nil {
		p := user.HasRole()
		if !*i.HasRole {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoleWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRoleWith))
		for _, w := range i.HasRoleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRoleWith(with...))
	}
	if i.HasPoliceStation != nil {
		p := user.HasPoliceStation()
		if !*i.HasPoliceStation {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPoliceStationWith) > 0 {
		with := make([]predicate.PoliceStation, 0, len(i.HasPoliceStationWith))
		for _, w := range i.HasPoliceStationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPoliceStationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPoliceStationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
